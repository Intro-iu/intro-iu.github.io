[{"title":"AX3000T刷uboot & qwrt","url":"/2023/10/12/AX3000T%E5%88%B7uboot&qwrt/","content":"破解SSH\n登录路由器后台，url中stok后面的数值替换为&lt;stok&gt;\n，使用windows 终端执行替换后的命令，返回值为0即可\ncurl -X POST http://192.168.1.1/cgi-bin/luci/;stok=&lt;stok&gt;/api/misystem/arn_switch -d &quot;open=1&amp;model=1&amp;level=%0Anvram%20set%20ssh_en%3D1%0A&quot;curl -X POST http://192.168.1.1/cgi-bin/luci/;stok=&lt;stok&gt;/api/misystem/arn_switch -d &quot;open=1&amp;model=1&amp;level=%0Anvram%20COMMIT%0A&quot;curl -X POST http://192.168.1.1/cgi-bin/luci/;stok=&lt;stok&gt;/api/misystem/arn_switch -d &quot;open=1&amp;model=1&amp;level=%0Ased%20-i%20&#x27;s%2Fchannel%3D.*%2Fchannel%3D%22debug%22%2Fg&#x27;%20%2Fetc%2Finit.d%2Fdropbear%0A&quot;curl -X POST http://192.168.1.1/cgi-bin/luci/;stok=&lt;stok&gt;/api/misystem/arn_switch -d &quot;open=1&amp;model=1&amp;level=%0A%2Fetc%2Finit.d%2Fdropbear%20start%0A&quot;\n备份分区\nssh 登录路由器后台，密码需要使用sn号进行换算，网址如下：\nhttps://miwifi.dev/ssh\n备份mtd，使用如下命令备份，由于tmp\n空间太小，备份一部分后请保存到本地电脑再继续备份\ndd if=/dev/mtd1 of=/tmp/BL2.bindd if=/dev/mtd2 of=/tmp/Nvram.bindd if=/dev/mtd3 of=/tmp/Bdata.bindd if=/dev/mtd4 of=/tmp/Factory.bindd if=/dev/mtd5 of=/tmp/FIP.bindd if=/dev/mtd6 of=/tmp/crash.bindd if=/dev/mtd7 of=/tmp/crash_log.bindd if=/dev/mtd8 of=/tmp/ubi.bindd if=/dev/mtd9 of=/tmp/ubi1.bindd if=/dev/mtd10 of=/tmp/overlay.bindd if=/dev/mtd11 of=/tmp/data.bindd if=/dev/mtd12 of=/tmp/KF.bin\n刷入UBoot\n上传uboot文件到tmp目录\n执行以下命令安装uboot\nmtd write *.bin FIP\n断电，按住reset 键后，插入电源线，等3秒左右即可进入uboot 界面\n刷入QWRT\n电脑设置固定ip 192.168.1.2 后，浏览器输入 http://192.168.1.1\n进入uboot\n，选择分区模式为qwrt，然后选择要更新的固件，点击uploa上传并更新\n更新并重启后等待3-5分钟，设备指示灯亮蓝灯即可，网线插入路由器从左到右数第二个接口，浏览器输入\nhttp://192.168.1.1 进入openwrt 界面\n","categories":["OpenWrt"],"tags":["UBoot","Router","Xiaomi-AX3000T"]},{"title":"Arch Linux 安装流程","url":"/2024/05/01/Arch-Installation/","content":"镜像准备\n前往镜像站下载\nhttps://mirrors.tuna.tsinghua.edu.cn/archlinux/iso\n安装流程\n基础安装\n加载镜像\n进入 VirtualBox 加载镜像\n校准时间\n# 列出时区timedatectl list-timezones# 设置时区timedatectl set-timezone Asia/Hong_Kong# 将系统时间与网络时间进行同步timedatectl set-ntp true# 检查服务状态timedatectl status\n切换镜像源\nvim /etc/pacman.d/mirrorlist\n# 中国科学技术大学开源镜像站Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch# 清华大学开源软件镜像站Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n全新安装\nlsblk # 显示当前分区情况\n建立分区表\nparted /dev/sdx # 执行 parted，进行磁盘类型变更(parted) mktable # 输入 mktable，建立分区表New disk label type? gpt # 输入 gpt，将磁盘类型转换为 GPT 类型。如磁盘有数据会警告，输入 Yes 即可(parted) quit # 退出 parted 命令行交互\n建立EFI分区\n具体的磁盘设备各有差异，SATA名称为sdx，NVME硬盘有另外的名称nvmexn1\n此处以 SATA 为例\n\nEFI分区：300M\n剩余空间自行分配\nSwap可选\n\ncfdisk /dev/sdx # 对安装 archlinux 的磁盘分区\nfdisk -l # 复查磁盘情况\n格式化 EFI 分区\nmkfs.fat -F32 /dev/sdx1\n格式化 Swap 分区（若有）\nmkswap /dev/sdxn\n格式化 Btrfs 分区\n将整一个分区格式化为 Btrfs 文件系统 mkfs.btrfs -fL Lingmo /dev/sdxn &gt; -L\n选项后指定该分区的\nLABLE，可以自定义，但不能使用特殊字符以及空格，且最好有意义\n挂载 Btrfs 分区\n# 将 Btrfs 分区挂载到 /mnt 下mount -t btrfs -o compress=zstd /dev/sdxn /mnt\n# 复查挂载情况df -h \n\n为后续创建子卷做准备\n\n相关参数： - -t：选项后指定挂载分区文件系统类型 -\n-o：选项后添加挂载参数： -\ncompress=zstd：开启透明压缩\n创建 Btrfs 子卷\n# 创建 / 目录子卷btrfs subvolume create /mnt/@ # 创建 /home 目录子卷btrfs subvolume create /mnt/@home \n# 复查子卷情况btrfs subvolume list -p /mnt\n卸载 /mnt\numount /mnt\n挂载各目录\n# 挂载 / 目录mount -t btrfs -o subvol=/@,compress=zstd /dev/sdxn /mnt # 创建 /home 目录mkdir /mnt/home # 挂载 /home 目录mount -t btrfs -o subvol=/@home,compress=zstd /dev/sdxn /mnt/home # 创建 /boot 目录mkdir -p /mnt/boot # 挂载 /boot 目录mount /dev/sdxn /mnt/boot # 挂载交换分区（如有）swapon /dev/sdxn \n安装系统\n\n使用 pacstrap 脚本安装基础包：\n\n\nPacstrap is designed to create a new system installation from\nscratch.\n\n# 如果使用btrfs文件系统，额外安装一个btrfs-progs包pacstrap /mnt base base-devel linux linux-firmware btrfs-progs\n相关参数： - base-devel：在 AUR\n包的安装过程中是必须用到的 -\nlinux：内核软件包，这里建议先不要替换为其它内核\n\n如果提示 GPG 证书错误，可能是因为使用的不是最新的镜像文件\n\n# 通过更新 archlinux-keyring 解决此问题pacman -S archlinux-keyring\n\n安装其它必要的功能性软件：\n\npacstrap /mnt networkmanager vim sudo zsh zsh-completions\n生成 fstab 文件\n\nfstab 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。\n\n# 使用 genfstab 自动根据当前挂载情况生成并写入 fstab 文件：genfstab -U /mnt &gt; /mnt/etc/fstab\n# 复查 /mnt/etc/fstabcat /mnt/etc/fstab\n如下：\n# /dev/sdb2 LABEL=LingmoUUID=d34ad4d9-8c4f-4ffc-adf4-6d5985dd4da3       /               btrfs           rw,relatime,compress=zstd:3,space_cache=v2,subvolid=256,subvol=/@       0 0# /dev/sdb2 LABEL=LingmoUUID=d34ad4d9-8c4f-4ffc-adf4-6d5985dd4da3       /home           btrfs           rw,relatime,compress=zstd:3,space_cache=v2,subvolid=257,subvol=/@home   0 0# /dev/sdb1UUID=4CF3-8291                                  /boot           vfat            rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro   0 2\n进入 chroot\narch-chroot /mnt\n修改主机名\n# 填入主机名vim /etc/hostname\n# 设置hostsvim /etc/hosts\n# 加入以下127.0.0.1   localhost::1         localhost127.0.1.1   myarch.localdomain myarch\n设置时区\n# 在 /etc/localtime 下用 /usr 中合适的时区创建符号链接ln -sf /usr/share/zoneinfo/Asia/Hong_Kong /etc/localtime\n硬件时间设置\nhwclock --systohc\n设置 Locale\n\nLocale 决定了软件使用的语言、书写习惯和字符集。\n\n# 编辑 /etc/locale.gen，去掉 en_US.UTF-8 UTF-8 以及 zh_CN.UTF-8 UTF-8 行前的注释符号（#）：vim /etc/locale.gen\n# 生成 localelocale-gen\n# 配置 locale.conf# 不推荐在此设置任何中文 locale，可能会导致 tty 乱码。echo &#x27;LANG=en_US.UTF-8&#x27; &gt; /etc/locale.conf\n为 root 用户设置密码\npasswd root\n安装微码\npacman -S intel-ucode   # Intelpacman -S amd-ucode     # AMD\n安装引导程序\n\n安装相应的包\n\npacman -S grub efibootmgr os-prober\n相关参数 - -S：选项后指定要通过 pacman\n包管理器安装的包： - grub：启动引导器 -\nefibootmgr：efibootmgr 被 grub 脚本用来将启动项写入 NVRAM -\nos-prober：为了能够引导 win10，需要安装 os-prober\n以检测到它\n\n安装 GRUB 到 EFI 分区\n\ngrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH # 可选参数：--removable\n相关参数 - --efi-directory=/boot：将 grubx64.efi\n安装到之前的指定位置（EFI 分区） -\n--bootloader-id=ARCH：取名为 ARCH -\n--removable：用于安装到移动介质\n\n编辑 /etc/default/grub 文件\n\nvim /etc/default/grub\n进行如下修改：\n\n去掉 GRUB_CMDLINE_LINUX_DEFAULT 一行中最后的 quiet\n参数\n把 loglevel 的数值从 3 改成\n5。这样是为了后续如果出现系统错误，方便排错\n加入 nowatchdog 参数，这可以显著提高开关机速度\n\n\n生成 GRUB 所需的配置文件\n\ngrub-mkconfig -o /boot/grub/grub.cfg\n完成安装\nexit umount -R /mnt reboot \n设置开机启动项\n# 启动 networkmanager 服务即可连接网络systemctl enable --now NetworkManager\n# 若为无线连接，则需要在启动 networkmanager 后使用 nmcli 连接网络：# 显示附近的 Wi-Fi 网络nmcli dev wifi list # 连接指定的无线网络nmcli dev wifi connect &quot;SSID&quot; password &quot;PWD&quot; \n也可以使用 nmtui 来配置网络 nmtui\n更新系统所有包 pacman -Syu\n使用 neofetch 打印系统信息 pacman -S neofetchneofetch\n添加用户 &amp; 进组 # -m: 建立 home 目录useradd -m username # 设置密码passwd username# -a: 在其之后可添加用户群组gpasswd -a user groupname \n安装 openssh 并启用 pacman -S opensshsystemctl enable --now sshd\n后日谈\nWhy Btrfs ?\n纵观 Btrfs 的历史，可以说 Btrfs\n未来的发展是道阻且长的。也让我们感受到开源社区也并不是一根绳上的蚂蚱 ——\n开源社区之间也有着各种各样的分歧。\n但不管怎么说，Btrfs 的未来现在来看是光明的；我们也可以在\narchlinux 上享受到 Btrfs\n文件系统的特性带来的好处：\n\n快照 archlinux 作为滚动发行版，若滚挂了可以使用 Btrfs\n的快照特性快速回滚 若使用传统的 ext4 文件系统，我们可以使用\ntimeshift 的 RSYNC\n模式进行增量备份。但是，一般来说 RSYNC\n方式的快照大小略大于当前实际使用大小，也就是说实际上开启了\ntimeshift 的 RSYNC\n模式快照相当于磁盘可用空间直接少了一半多。因为虽然 RSYNC\n方式的快照是增量的，但历史最久远的快照依然是完整备份，随后才是增量的\n透明压缩 可以大大减少磁盘的使用空间（压缩率大概在 10%\n左右）\n\n","categories":["OpenWrt"],"tags":["Linux","ArchLinux"]},{"title":"Circuit","url":"/2024/03/30/Circuit/","content":"基本概念\n电源与负载\n\n电源：把能够输出电能或电信号的器件称为电源\n负载：把要求输入电能或电信号的器件称为负载\n\n线性元件\n\n线性元件：当元件的电磁特性为线性关系时称为线性元件\n非线性元件：当元件的电磁特性为非线性关系时称为非线性元件\n线性电路：有电源和线性元件组成的电路称为线性电路\n非线性电路：不能用线性方程来描述的电路称为非线性电路\n\n时变参数元件\n\n时变参数元件：参数随时间而变化的元件称为时变参数元件\n非时变参数元件：参数不随时间而变化的元件称为非时变参数元件\n\n集中参数元件\n\n集中参数元件：当元件各向尺寸远小于电磁量工作频率所对应的电磁波波长而无需考虑电磁量的空间分布时，这种元件称为集中参数元件\n集中参数电路：仅含集中参数元件的电路称为集中参数电路\n分布参数电路：需要考虑电磁量的空间分布性的电路称为分布参数电路\n\n直流和交流\n\n直流：量值和方向不随时间变化的电流称为直流\n交流：随时间作周期性变化且平均值为零的电流称为交流\n\n直流电压与交变电压\n\n当电压的量值和极性不随时间变化时，称为直流电压\n作周期性变化且平均值为零的电压称为交变电压\n\n关联参考方向\n\n将一个元件上的电压和电流的参考方向取成相同的称为关联参考方向\n将一个元件上的电压和电流的参数方向取成相反的称为非关联参考方向\n\n基尔霍夫电流定律\n内容\n在集中参数电路中，任一时刻流出（或流入）任一节点的支路电流代数和等于零，即\n\\[\n\\sum i_k = 0\n\\]\n推广\n在集中参数电路中，任一时刻流出（或流入）任一闭合边界 \\(S\\) 的支路电流代数和为零，即\n\\[\n\\sum i_k = 0\n\\]\n称为广义基尔霍夫电流定律。\n基尔霍夫电压定律\n内容\n在集中参数电路中，任一时刻沿任一回路各支路电压的代数和等于零，即\n\\[\n\\sum u_k = 0\n\\]\n推广\n沿任一回路，各支路电压降的代数和等于电压升的代数和，即\n\\[\n\\sum u_{电压降} = \\sum u_{电压升}\n\\]\n电阻等效\n\n\\(\\Delta\\) 形联结到 \\(Y\\) 形联结的等效变换公式\n\n\\[\n\\begin{split}\n    &amp;R_1 = \\frac{R_{12}R_{31}}{R_{12} + R_{23} + R_{31}} \\\\\n    &amp;R_2 = \\frac{R_{12}R_{23}}{R_{12} + R_{23} + R_{31}} \\\\\n    &amp;R_3 = \\frac{R_{23}R_{31}}{R_{12} + R_{23} + R_{31}} \\\\\n\\end{split}\n\\]\n\n\\(Y\\) 形联结到 \\(\\Delta\\) 形联结的等效变换公式\n\n\\[\n\\begin{split}\n    &amp;R_{12} = \\frac{R_1R_2 + R_2R_3 + R_3R_1}{R_3} \\\\\n    &amp;R_{23} = \\frac{R_1R_2 + R_2R_3 + R_3R_1}{R_1} \\\\\n    &amp;R_{31} = \\frac{R_1R_2 + R_2R_3 + R_3R_1}{R_2} \\\\\n\\end{split}\n\\]\n若三个电阻相等，则\n\\[\nR_\\Delta = 3 R_Y\n\\]\n支路电流法\n定义\n设给定的线性直流电路具有 \\(b\\)\n条支路，\\(n\\)\n个节点，其中各独立电源、受控电源和电阻的参数均为已知，要求确定各支路的电流或电压。\n支路电流法就是以 \\(b\\) 条位置的支路电流作为待求量，对 \\(n-1\\) 个节点列出独立的 KCL\n方程，再对 \\(b-(n-1)\\) 个回路列出独立的\nKVL 方程。这 \\(b\\)\n个方程联立便可解得 \\(b\\)\n个支路电流。\n回路电流法\n选择 \\(b-(n-1)\\)\n个独立回路，以各回路电流为待求量列写 KVL\n方程。这种分析方法称为回路电流法或**回路分析法。\n"},{"title":"连续","url":"/2024/03/12/Continuity/","content":"连续\n定义\n设函数  在点  的某一邻域内有定义，如果  那么就称函数 \n在点  连续。\n也可表述为：\n设函数  在点  的某一邻域内有定义，如果  那么就称函数  在点\n 连续。\n也可用 \n语言表述为： 在点连续当时有\n如果  存在且等于 ，即  那么就说函数  在点\n 左连续。\n同理，如果  存在且等于 ，即  那么就说函数  在点\n 右连续。\n在区间上每一点都连续的函数，叫做在该区间上的连续函数，或者说函数在该区间上连续。如果区间包括端点，那么函数在右端点连续是指左连续，在左端点连续是指右连续。\n运算\n定理 \n设函数  和  在点  连续，则它们的和（差）、积  及商 （当  时）都在点  连续。\n定理 \n如果函数  在区间 \n上单调增加（或单调减少）且连续，那么它的反函数  也在对应的区间 \n上单调增加（或单调减少）且连续。\n定理 \n设函数 \n由函数  与函数  复合而成，。若 ，而函数  在\n 连续，则 \n定理 \n设函数 \n由函数  与函数  复合而成，。若函数  在\n 连续，且 ，而函数  在  连续，则复合函数  在  也连续。\n一切初等函数在其定义区间内都是连续的。\n性质\n如果函数  在开区间  内连续，在右端点  左连续，在左端点  右连续，那么函数  就是在闭区间  上连续的。\n定理 （有界性与最大值最小值定理）\n在闭区间上连续的函数在该区间上有界且一定能取得它的最大值和最小值。\n定理 （零点定理） 设函数  在闭区间  上连续，且  与  异号（即 ），则在开区间\n 内至少有一点 ，使 \n定理 （介值定理） 设函数  在闭区间 \n上连续，且在这区间的端点取不同的函数值 及 则对于  与  之间任意一个数 ，在开区间  内至少有一点 ，使得 \n推论\n在闭区间  上连续的函数  的值域为闭区间 ，其中  与  依次为  在  上的最小值与最大值。 # 间断点 ## 定义 设函数  在点 \n的某去心邻域内有定义。在此前提下，如果函数  有下列三种情形之一： 1. 在  没有定义 2. 虽在  有定义，但  不存在 3. 虽在\n 有定义，且  存在，但 \n那么函数  在点  为不连续，而点  称为函数 \n的不连续点或间断点。\n分类\n\n如果  是函数  的间断点，但左极限  及右极限  都存在，那么  称为函数 \n的第一类间断点。若左右极限相等，称为可去间断点，否则称为跳跃间断点。\n不是第一类间断点的任何间断点，称为第二类间断点。如无穷间断点和振荡间断点。\n\n","tags":["Math"]},{"title":"导数","url":"/2024/03/12/Derivative/","content":"导数\n定义\n设函数  在点  的某个邻域内有定义，当自变量  在  处取得增量 （点 \n仍在该邻域内）时，相应地，因变量取得增量 ；如果  与\n 之比当  时的极限存在，那么称函数\n 在点 \n处可导，并称这个极限为函数  在点  处的导数，记为 ，即  也可记作 ， 或 \n如果函数  在开区间  内的每点处都可导，那么就称函数  在开区间  内可导。这是，对于任一 ，都对应这 \n的一个确定的导数值。这样就构成了一个新的函数，这个函数叫做原来函数  的导函数，记作\n，， 或 \n函数  在 \n处的左导数和右导数，记作  及   函数  在点  处可导的充分必要条件是左导数  和右导数  都存在且相等。\n如果函数  在开区间  内可导，且  及  都存在，那么就说  在闭区间  上可导。\n性质\n如果函数  在点  处可导，那么函数在该点必连续。\n求导法则\n定理 \n如果函数  及  都在点 \n具有导数，那么它们的和、差、积、商（除分母为零的点外）都在点  具有导数，且 1.  2.  3. \n定理 \n如果函数  在区间  内单调、可导且 ，那么它的反函数  在区间 \n内也可导，且 或\n定理 \n如果  在点  可导，而  在点 \n可导，那么复合函数  在点 \n可导，且其导数为 或\n隐函数的导数\n由参数方程所确定的函数的导数\n微分\n定义\n设函数 \n在某区间内有定义， 及  在这区间内，如果函数的增量\n 可表示为  其中  是不依赖于  的常数，那么称函数  在点  是可微的，而  叫做函数  在点  相应于自变量增量  的微分，记作 ，即  函数  在点  可微的充分必要条件是函数  在点  可导，且当  在点  可微时，其微分一定是 \n函数  在任意点 \n的微分，称为函数的微分，记作  或 ，即  通常把自变量  的增量\n\n称为自变量的微分，记作 ，即 ，于是函数  的微分又可记作  从而有 \n微分法则\n\n基本初等函数的微分公式\n函数和、差、积、商的微分法则\n复合函数的微分法则\n\n微分中值定理\n费马引理\n设函数  在点  的某邻域  内有定义，并且在  处可导，如果对任意的 ，有 （或） 那么 。\n通常称导数等于零的点为函数的驻点（或稳定点，临界点）。\n罗尔定理\n如果函数  满足 1. 在闭区间\n 上连续 2. 在开区间  内可导 3.\n在区间端点处的函数值相等，即 \n那么在  内至少有一点 （），使得 。\n拉格朗日中值定理\n如果函数  满足 1. 在闭区间\n 上连续 2. 在开区间  内可导\n那么在  内至少有一点 （），使等式  成立\n柯西中值定理\n如果函数  及  满足 1. 在闭区间  上连续 2. 在开区间  内可导 3. 对任一 \n那么在  内至少有一点 ，使等式  成立\n推论\n如果函数  在区间  上连续， 内可导且导数恒为零，那么  在区间  上是一个常数。\n洛必达法则\n如果当 （或 ）时，两个函数  与  都趋于零或都趋于无穷大，那么极限\n\n可能存在、也可能不存在。通常把这种极限叫做未定式，并分别简记为\n 或 。\n定理 1\n设 1. 当  时，函数  及  都趋于零 2. 在点  的某去心邻域内， 及  都存在且  3.  存在（或为无穷大）\n则 \n定理 2\n设 1. 当  时，函数\n 及  都趋于零 2. 当  时  及  都存在且  3.  存在（或为无穷大）\n则 \n泰勒公式\n泰勒中值定理 1\n如果函数  在  处具有  阶导数，那么存在  的一个邻域，对于该邻域内的任一 ，有  其中  称其为佩亚诺余项。\n泰勒中值定理 2\n如果函数  在  的某个邻域  具有  阶导数，那么对任一 ，有  其中  这里  是  与 \n之间的某个值，称其为拉格朗日余项。\n","tags":["Math","Calculus"]},{"title":"微分方程","url":"/2024/03/13/Differential-Equation/","content":"高阶线性微分方程\n常系数齐次线性微分方程\n定义\n在二阶齐次线性微分方程  中，如果 ， 的系数 ， 均为常数  其中 \n是常数，那么称其为二阶常系数齐次线性微分方程。如果\n\n不全为常数，称其为二阶变系数齐次线性微分方程。\n解法\n称 \n为微分方程的特征方程。\n微分方程的通解有三种不同的情形 1. 特征方程有两个不相等的实根：\n微分方程的通解为 \n\n特征方程有两个相等的实根：\n\n微分方程的通解为 \n\n特征方程有一对共轭复根：，（）\n\n此时微分方程的通解为 \n拓展\n\n阶常系数齐次线性微分方程的一般形式是  其中  都是常数。\n此时微分方程的特征方程为 \n根据特征方程的根，可以写出其对应的微分方程的解如下：\n\n\n\n\n\n\n\n特征方程的根\n微分方程通解中的对应项\n\n\n\n\n 重实根 \n\n\n\n一对  重复根 \n\n\n\n\n从代数学知道， 次代数方程有\n\n个根（重根按重数计算），而特征方程的每一个根都对应着通解中的一项，且每项各含一个任意常数，这样就得到\n 阶常系数齐次线性微分方程的通解\n\n","tags":["Math","Calculus"]},{"title":"函数","url":"/2024/03/12/Function/","content":"映射\n定义\n设 \n是两个非空集合，如果存在一个法则 ，使得对  中每个元素 ，按法则 ，在  中有唯一确定的元素  与之对应，那么称  为从  到  的映射，记作\n\n其中  称为元素 （在映射  下）的像，并记作 ，即\n\n而元素  称为元素 （在映射  下）的一个原像；集合\n 称为映射  的定义域，记作 ； 中所有元素的像所组成的集合称为映射\n 的值域，记作  或 ，即\n\n从上述映射的定义中，需要注意的是：\n\n构成一个映射必须具备以下三个要素：集合 ，即定义域 ；集合 ，即值域的范围：；对应法则 ，使对每个 ，有唯一确定的 与之对应。\n对每个 ，元素  的像  是唯一的；而对每个 ，元素  的原像不一定是唯一的；映射  的值域  是  的一个子集，即 ，不一定 。\n\n设  是从集合  到集合  的映射，若 ，即  中任一元素  都是  中某元素的像，则称  为  到 \n上的映射或满射；若对  中任一两个不同元素 ，它们的像 ，则称  为  到  的单射；若映射  既是单射，又是满射，则称 \n为一一映射（或双射）。\n逆映射\n设  是  到  的单射，则由定义，对每个 ，有唯一的 ，适合 。于是，我们可定义一个从  到  的新映射 ，即\n\n对每个 ，规定 ，这  满足 。这个映射  称为  的逆映射，记作 ，其定义域 ，值域 。、\n复合映射\n设有两个映射\n\n其中 ，则由映射\n 和  可以定出一个从  到  的对应法则，它将每个  映成 。显然，这个对应法则确定了一个从  到  的映射，这个映射称为映射  和  构成的复合映射，记作\n，即\n\n由复合映射的定义可知，映射  和\n 构成复合映射的条件是： 的值域  必须包含在  的定义域内，即 。否则，不能构成复合映射。由此可以知道，映射  和  的复合是有顺序的， 由意义并不表示  有意义。即使  和  都有意义，复合映射  与  也未必相同。\n函数\n定义\n设数集 ，则称映射\n 为定义在  上的**函数，通常简记为\n\n其中 \n称为自变量，\n称为因变量，\n称为定义域，记作 ，即 。\n函数的定义中，对每个 ，按对应法则 ，总有唯一确定的值  与之对应，这个值称为函数  在  处的函数值，记作 ，即 。因变量  与自变量\n\n之间的这种依赖关系，通常称为函数关系。函数值  的全体所构成的集合称为函数  的值域，记作  或 ，即\n\n性质\n\n函数的有界性 设函数  的定义域为 ，数集 ，如果存在数 ，使得\n\n\n对任一 \n都成立，那么称函数  在  上有上界，而  称为函数  在  上的一个上界。如果存在数 ，使得\n\n对任一 \n都成立，那么称函数  在  上有下界，而  称为函数  在  上的一个下界。如果存在正数 ，使得\n\n对任一  都成立，那么函数\n 在  上有界。如果这样的\n 不存在，就称函数  在  上无界。\n\n函数的单调性\n函数的奇偶性\n函数的周期性\n\n反函数\n设函数 \n是单射，则它存在逆映射 ，称此映射  为函数  的反函数。\n按此定义，对每个 ，有唯一的 ，使得 ，于是有\n\n复合函数\n设函数  的定义域为 ，函数  的定义域为 ，且其值域 ，则由下式确定的函数\n\n称为由函数  与函数 \n构成的复合函数，它的定义域为 ，变量  称为中间变量。\n函数  与函数  构成的复合函数，即按“先  后 ”的次序复合的函数，通常记为 ，即\n\n与复合映射一样， 与  能构成复合函数  的条件是：函数  的值域  必须包含于函数  的定义域 ，即 \n函数的运算\n设函数  的定义域依次为\n，则我们定义这两个函数的下列运算： - 和（差）： - 积 ： - 商 ：\n初等函数\n\n幂函数：（）是函数\n指数函数：（ 且 ）\n对数函数：（ 且 ）\n三角函数：如 \n反三角函数：如 \n\n以上这五类函数统称为基本初等函数。\n有常数和基本初等函数经过有限次的四则运算和有限次的函数复合步骤所构成并可用一个式子表示的函数，称为初等函数。\n","tags":["Math"]},{"title":"AI项目常规入门流程（Kaggle泰坦尼克号为例）","url":"/2024/01/11/How-To-Fuck-An-AI-Program/","content":"数据处理\n常用的库\nimport pandas as pdimport numpy as npimport seaborn as sns import matplotlib.pyplot as plt%matplotlib inline\n数据读取\ntrain_data = pd.read_csv(&#x27;./train.csv&#x27;)test_data  = pd.read_csv(&#x27;./test.csv&#x27;)\n数据分析\n\n数据输出\n\ntrain_data.head()   # 输出前五行训练数据test_data.head()    # 输出前五行测试数据 \nprint(&quot;Total number of rows in training data &quot;, train_data.shape[0])print(&quot;Total number of columns in training data &quot;, train_data.shape[1])print(&quot;Total number of rows in test data &quot;, test_data.shape[0])print(&quot;Total number of columns in test data &quot;, test_data.shape[1])\n\n绘制图片表格\n\nplt.figure(figsize = (13,5))plt.bar(train_data.columns, train_data.isna().sum())plt.xlabel(&quot;Columns name&quot;)plt.ylabel(&quot;Number of missing values in training data&quot;) # 反映数据缺失情况plt.show()\n\nPLT的各种表格绘制\n\n\n在此不多赘述，但作用不小，可以很直观地反映特征分布情况，便于后续缩小模型等操作\n\n\n计算数字表格\n\n# 分组计算，以此为例，输出男女幸存者/遇难者在同性中的占比(train_data.groupby([&#x27;Sex&#x27;,&#x27;Survived&#x27;]).Survived.count() * 100) / train_data.groupby(&#x27;Sex&#x27;).Survived.count()\n数据清洗\n\n删除无用信息\n\ntrain_data.drop(&#x27;Cabin&#x27;, axis = 1, inplace = True)test_data.drop(&#x27;Cabin&#x27;, axis = 1, inplace = True)#:--------------------------------------------------:#columns_to_drop = [&#x27;PassengerId&#x27;,&#x27;Ticket&#x27;]train_data.drop(columns_to_drop, axis = 1, inplace = True)# 后续要根据乘客ID来代表幸存者，故测试集不能删除PassengerIdtest_data.drop(columns_to_drop[1], axis = 1, inplace = True) \n\n查看并填充缺失值\n\ncombined_data = [train_data, test_data]# 输出训练集与测试集的缺失值情况for data in combined_data:    print(data.isnull().sum())    print(&#x27;*&#x27; * 20)# 用平均值替代缺失值（年龄、票价）for data in combined_data:    data.Age.fillna(data.Age.mean(), inplace = True)    data.Fare.fillna(data.Fare.mean(), inplace = True)# 以泰坦尼克号数据为例，最多登船港口为Southampton，故填充缺失港口为Southampton# 由此也可知缺失值替换不一定依赖于平均值，应该由实际情况出发train_data[&#x27;Embarked&#x27;].fillna(&#x27;S&#x27;, inplace = True)\n\n处理分类型特征\n\n# 性别train_data.Sex = train_data.Sex.map(&#123;&#x27;female&#x27;: 0, &#x27;male&#x27;: 1&#125;)test_data.Sex = test_data.Sex.map(&#123;&#x27;female&#x27;: 0, &#x27;male&#x27;: 1&#125;)# 登船港口train_data.Embarked = train_data.Embarked.map(&#123;&#x27;S&#x27;: 0, &#x27;C&#x27;: 1, &#x27;Q&#x27;: 2&#125;)test_data.Embarked = test_data.Embarked.map(&#123;&#x27;S&#x27;: 0, &#x27;C&#x27;: 1, &#x27;Q&#x27;: 2&#125;)\n特征工程\n\n例如有无伴侣/父母/兄弟/子女随同可总结为是否独自前往\n\ntrain_data[&#x27;Alone&#x27;] = train_data.SibSp + train_data.Parchtest_data[&#x27;Alone&#x27;] = test_data.SibSp + test_data.Parchtrain_data.loc[train_data.Alone == 0, &#x27;Alone&#x27;] = 1test_data.loc[test_data.Alone == 0, &#x27;Alone&#x27;] = 1train_data.drop([&#x27;SibSp&#x27;,&#x27;Parch&#x27;], axis = 1, inplace = True)test_data.drop([&#x27;SibSp&#x27;,&#x27;Parch&#x27;], axis = 1, inplace = True )\n\n例如人物头衔\n\n# 输出头衔数量（采用了正则化表达式提取中间名为头衔）train_data.Name.str.extract(&#x27; ([A-Za-z]+)\\.&#x27;, expand=False).unique().size# 提取头衔，删除名字for data in combined_data:    data[&#x27;Title&#x27;] = data.Name.str.extract(&#x27;([A-Za-z]+)\\.&#x27;, expand = False)    data.drop(&#x27;Name&#x27;, axis = 1, inplace = True)# 输出头衔及数量train_data.Title.value_counts()# 将出现次数少的头衔一律替换为Rare（缩小模型）least_occuring = [ &#x27;Don&#x27;, &#x27;Rev&#x27;, &#x27;Dr&#x27;, &#x27;Mme&#x27;, &#x27;Ms&#x27;,       &#x27;Major&#x27;, &#x27;Lady&#x27;, &#x27;Sir&#x27;, &#x27;Mlle&#x27;, &#x27;Col&#x27;, &#x27;Capt&#x27;, &#x27;Countess&#x27;,&#x27;Dona&#x27;,       &#x27;Jonkheer&#x27;]for data in combined_data:    data.Title = data.Title.replace(least_occuring, &#x27;Rare&#x27;)# 将头衔映射为数字title_mapping = &#123;&quot;Mr&quot;: 1, &quot;Miss&quot;: 2, &quot;Mrs&quot;: 3, &quot;Master&quot;: 4, &quot;Rare&quot;: 5&#125;for data in combined_data:    data[&#x27;Title&#x27;] = data[&#x27;Title&#x27;].map(title_mapping)\n\n提取年龄特征\n\n# 将年龄分组for dataset in combined_data:        dataset.loc[ dataset[&#x27;Age&#x27;] &lt;= 16, &#x27;Age&#x27;] = 0    dataset.loc[(dataset[&#x27;Age&#x27;] &gt; 16) &amp; (dataset[&#x27;Age&#x27;] &lt;= 32), &#x27;Age&#x27;] = 1    dataset.loc[(dataset[&#x27;Age&#x27;] &gt; 32) &amp; (dataset[&#x27;Age&#x27;] &lt;= 48), &#x27;Age&#x27;] = 2    dataset.loc[(dataset[&#x27;Age&#x27;] &gt; 48) &amp; (dataset[&#x27;Age&#x27;] &lt;= 64), &#x27;Age&#x27;] = 3    dataset.loc[ dataset[&#x27;Age&#x27;] &gt; 64, &#x27;Age&#x27;] = 4\n\n关于loc的选取\n\n# loc 用于选取行和列# 表示选择 df 数据集中行标签为 &#x27;a&#x27;，列标签为 &#x27;b&#x27; 的单个元素df.loc[&#x27;a&#x27;, &#x27;b&#x27;] # 也可以使用表达式定位，表示选择 df 数据集中年龄大于18的乘客的名字df.loc[df[&#x27;Age&#x27;] &gt; 18, &#x27;Name&#x27;] \n数据预备\nimport torchX_train = train_data.drop(&quot;Survived&quot;, axis=1)Y_train = train_data[&quot;Survived&quot;]X_test = test_data.drop(&quot;PassengerId&quot;, axis=1)print(&quot;shape of X_train&quot;,X_train.shape)print(&quot;Shape of Y_train&quot;,Y_train.shape)print(&quot;Shape of x_test&quot;,X_test.shape)# 将数据转换为tensorX_train = torch.tensor(X_train.values).float()Y_train = torch.tensor(Y_train).float().view(-1, 1)X_test = torch.tensor(X_test.values).float()\n神经网络\n常用库\nimport torchimport torch.nn as nnimport torch.optim as optim\n网络搭建 &amp; 训练\n# 定义线性回归模型类class LinearRegression(nn.Module):    def __init__(self, input_size, output_size):        super(LinearRegression, self).__init__()                # 定义线性层        self.linear0 = nn.Linear(input_size, 42)        self.linear1 = nn.Linear(42, 168)        self.linear2 = nn.Linear(168, 84)        self.linear3 = nn.Linear(84, output_size)                        self.relu = nn.ReLU()        # 定义一个sigmoid激活函数，用于将线性输出转换为概率        self.sigmoid = nn.Sigmoid()    def forward(self, x):        # 前向传播，计算模型的输出        out = self.linear0(x)        out = self.relu(out)                out = self.linear1(out)        out = self.relu(out)                out = self.linear2(out)        out = self.relu(out)                out = self.linear3(out)        out = self.sigmoid(out)                return out# 定义超参数input_size = 7 # 输入特征的维度output_size = 1 # 输出概率的维度learning_rate = 0.01 # 学习率epochs = 200 # 训练轮数# 创建模型实例model = LinearRegression(input_size, output_size)# 定义损失函数，使用二元交叉熵损失criterion = nn.BCELoss()# 定义优化器，使用adam优化器optimizer = optim.Adam(model.parameters(), lr=learning_rate)# 训练模型for epoch in range(epochs):    # 前向传播，计算模型的输出和损失    outputs = model(X_train)    loss = criterion(outputs, Y_train)    # 反向传播，计算梯度并更新参数    optimizer.zero_grad()    loss.backward()    optimizer.step()    # 打印每轮的损失    print(f&#x27;Epoch &#123;epoch+1&#125;, Loss: &#123;loss.item():.4f&#125;&#x27;)\n模型评估\nfrom sklearn import metricsY_pred_rand = (model(X_train) &gt; 0.5).to(torch.int)print(&#x27;Precision : &#x27;, np.round(metrics.precision_score(Y_train, Y_pred_rand)*100,2))print(&#x27;Accuracy : &#x27;, np.round(metrics.accuracy_score(Y_train, Y_pred_rand)*100,2))print(&#x27;Recall : &#x27;, np.round(metrics.recall_score(Y_train, Y_pred_rand)*100,2))print(&#x27;F1 score : &#x27;, np.round(metrics.f1_score(Y_train, Y_pred_rand)*100,2))print(&#x27;AUC : &#x27;, np.round(metrics.roc_auc_score(Y_train, Y_pred_rand)*100,2))\n\n关于各评估指标\n\n\n\n\n\n\n\n\n指标\n作用\n\n\n\n\n精确度(Precision)\n表示模型预测为正类别中实际为正类别的比例。\n\n\n准确率(Accuracy)\n表示模型正确预测的样本占总样本的比例。\n\n\n召回率(Recall)\n表示实际为正类别中模型预测为正类别的比例。\n\n\nF1分数(F1 score)\n是精确度和召回率的调和平均数，用于衡量模型的整体性能。\n\n\nAUC\n表示模型区分正负类别的能力，值越高表示模型性能越好。\n\n\n\n# 绘制混淆矩阵的热力图matrix = metrics.confusion_matrix(Y_train, Y_pred_rand)sns.heatmap(matrix, annot = True,fmt = &#x27;g&#x27;)plt.show()\n预测 &amp; 提交\n模型预测\npredict = model(X_test)predict = (predict &gt; 0.5).to(torch.int).ravel()print(predict)\n提交\nsubmit = pd.DataFrame(&#123;&quot;PassengerId&quot;:test_data.PassengerId, &#x27;Survived&#x27;:predict&#125;)submit.to_csv(&quot;final_submission.csv&quot;,index = False) # index参数来防止在 CSV 文件中添加索引列\n推荐网站\nKaggle\n","categories":["AI"],"tags":["Python","Kaggle","AI"]},{"url":"/2024/04/02/Limit/","content":"数列的极限\n定义\n设 \\(\\{x_n\\}\\)\n为一数列，如果存在常数 \\(a\\)，是对于任意给定的正数 \\(\\epsilon\\)（不论它多么小），总存在正整数\n\\(N\\)，使得当 \\(n &gt; N\\)时，不等式 \\[\n\\left\\vert x_n - a \\right\\vert &lt; \\varepsilon\n\\] 都成立，那么就称常数 \\(a\\)\n是数列 \\(\\{x_n\\}\\)\n的极限，或者称数列 \\(\\{x_n\\}\\) 收敛于 \\(a\\)，记为 \\[\n\\lim\\limits_{n \\to \\infty }x_n = a\n\\] 或 \\[\nx_n \\to a \\quad (n \\to \\infty)\n\\] 如果不存在这样的常数 \\(a\\)，就说数列 \\(\\{x_n\\}\\) 没有极限，或者说数列 \\(\\{x_n\\}\\)\n是发散的，习惯上也说 \\(\\lim\\limits_{n \\to \\infty}x_n\\)\n不存在。\n数列极限 \\(\\lim\\limits_{n\\to\\infty}x_n =\na\\) 的定义可表达为 \\[\n\\lim\\limits_{n \\to \\infty}x_n = a \\Leftrightarrow \\forall \\varepsilon\n&gt; 0, \\,\n\\exists \\,正整数\\,N，当\\,n &gt; N\\,时，有\\,\\left\\vert x_n - a\\right\\vert\n&lt; \\varepsilon\n\\]\n性质\n定理 \\(1\\)（极限的唯一性）\\(\\quad\\) 如果数列 \\(\\{x_n\\}\\) 收敛，那么它的极限唯一。\n定理 \\(2\\)（收敛数列的有界性）\\(\\quad\\) 如果数列 \\(\\{x_n\\}\\) 收敛，那么数列 \\(\\{x_n\\}\\) 一定有界。\n定理 \\(3\\)（收敛数列的保号性）\\(\\quad\\) 如果 \\(\\lim\\limits_{n \\to \\infty}x_n = a\\)，且\n\\(a &gt; 0\\)（或 \\(a &lt; 0\\)），那么存在正整数 \\(N\\)，当 \\(n &gt;\nN\\) 时，都有 \\(x_n &gt; 0\\)（或\n\\(x_n &lt; 0\\)）。\n推论\\(\\quad\\)\n如果数列 \\(\\{x_n\\}\\) 从某项起有 \\(x_n \\ge 0\\)（或 \\(x_n \\le 0\\)），且 \\(\\lim\\limits_{n\\to\\infty} x_n = a\\)，那么\n\\(a \\ge 0\\)（或 \\(a \\le 0\\)）。\n定理 \\(4\\)（收敛数列与其子数列间的关系）\\(\\quad\\) 如果数列 \\(\\{x_n\\}\\) 收敛于 \\(a\\)，那么它的任一子数列也收敛，且极限也是\n\\(a\\)。\n函数的极限\n定义\n定义 \\(1\\quad\\)\n设函数 \\(f(x)\\) 在点 \\(x_0\\) 的某一去心邻域内有定义。如果存在常数\n\\(A\\)，对于任一给定的正数 \\(\\varepsilon\\)（不论它多么小），总存在正数\n\\(\\delta\\)，使得当 \\(x\\) 满足不等式 \\(0 &lt; \\left\\vert x - x_0 \\right\\vert &lt;\n\\delta\\) 时，对应的函数值 \\(f(x)\\) 都满足不等式 \\[\n\\left\\vert f(x) &lt; A \\right\\vert &lt; \\varepsilon\n\\] 那么常数 \\(A\\)\n就叫做函数 \\(f(x)\\) 当 \\(x\\to x_0\\) 时的极限，记作 \\[\n\\lim\\limits_{x\\to x_0}f(x) = A\\ 或\\ f(x) \\to A\\ (\\ 当\\ x \\to x_0\\ )\n\\] 定义 \\(1\\) 可以简单的表述为\n\\[\n\\lim\\limits_{x\\to x_0}f(x) = A \\Leftrightarrow \\forall \\varepsilon &gt;\n0, \\exists \\delta &gt; 0, 当 0 &lt; \\left\\vert x - x_0 \\right\\vert &lt;\n\\delta 时, 有 \\left\\vert f(x) - A \\right\\vert &lt; \\varepsilon\n\\] 在 \\(\\lim\\limits_{x\\to x_0}f(x) =\nA\\) 的定义中，把 \\(0 &lt; \\left\\vert x\n- x_0 \\right\\vert &lt; \\delta\\) 改为 \\(x_0 - \\delta &lt; x &lt; x_0\\)，那么 \\(A\\) 就叫做函数 \\(f(x)\\) 当 \\(x \\to\nx_0\\) 时的左极限，记作 \\[\n\\lim\\limits_{x \\to x^-_0}f(x) = A \\quad 或 \\quad f(x_0^-) = A\n\\] 类似的，把 \\(0 &lt; \\left\\vert x -\nx_0\\right\\vert &lt; \\delta\\) 改为 \\(x_0\n&lt; x &lt; x_0 + \\delta\\)，那么 \\(A\\) 就叫做函数 \\(f(x)\\) 当 \\(x \\to\nx_0\\) 时的右极限，记作 \\[\n\\lim\\limits_{x \\to x^+_0}f(x) = A \\quad 或 \\quad f(x_0^+) = A\n\\] 函数 \\(f(x)\\) 当 \\(x \\to x_0\\)\n时极限存在的充分必要条件是左极限及右极限各自存在并且相等，即 \\[\nf(x_0^-) = f(x_0^+)\n\\] 定义 \\(2\\quad\\) 设函数 \\(f(x)\\) 当 \\(\\left\\vert x\\right\\vert\\)\n大于某一正数时有定义。如果存在常数 \\(A\\)，对于任意给定的正数 \\(\\varepsilon\\)，总存在正数 \\(X\\)，使得当 \\(x\\) 满足不等式 \\(\\left\\vert x\\right\\vert &gt; X\\)\n时，对应的函数值 \\(f(x)\\) 都满足不等式\n\\[\n\\left\\vert f(x) - A \\right\\vert &lt; \\varepsilon\n\\] 那么常数 \\(A\\)\n就叫做函数 \\(f(x)\\) 当 \\(x \\to \\infty\\) 时的极限，记作\n\\[\n\\lim\\limits_{x \\to \\infty} = A \\quad 或 \\quad f(x) \\to A (当 x\\to\n\\infty)\n\\] 定义 \\(2\\) 可简单地表达为\n\\[\n\\lim\\limits_{x \\to \\infty} f(x) = A \\Leftrightarrow \\forall \\varepsilon\n&gt; 0, \\exists X &gt; 0, 当 \\left\\vert x \\right\\vert &gt; X时，有\n\\left\\vert f(x) - A \\right\\vert &lt; \\varepsilon\n\\]\n性质\n定理 \\(1\\)（函数极限的唯一性）\\(\\quad\\) 如果 \\(\\lim\\limits_{x \\to x_0} f(x)\\)\n存在，那么这极限唯一。\n定理 \\(2\\)（函数极限的局部有界性）\\(\\quad\\) 如果 \\(\\lim\\limits_{x \\to x_0}f(x) =\nA\\)，那么存在常数 \\(M&gt;0\\) 和\n\\(\\delta &gt; 0\\)，使得当 \\(0 &lt; \\left\\vert x - x_0 \\right\\vert &lt;\n\\delta\\) 时，有 \\(\\left\\vert f(x)\n\\right\\vert \\le M\\)。\n定理 \\(3\\)（函数极限的局部保号性）\\(\\quad\\) 如果 \\(\\lim\\limits_{x \\to x_0}f(x) = A\\)，且 \\(A &gt; 0\\)（或 \\(A &lt; 0\\)，那么存在常数 \\(\\delta &gt; 0\\)，使得当 \\(0 &lt; \\left\\vert x - x_0 \\right\\vert &lt;\n\\delta\\) 时，有 \\(f(x) &gt;\n0\\)（或 \\(f(x) &lt; 0\\)）。\n定理 \\(3^\\prime\\quad\\) 如果 \\(\\lim\\limits_{x \\to x_0}f(x) = A(A \\ne\n0)\\)，那么就存在着 \\(x_0\\)\n的某一去心邻域 \\(\\mathring{U}(x_0)\\)，当 \\(x \\in \\mathring{U}(x_0)\\) 时，就有 \\(\\left\\vert f(x) \\right\\vert &gt; \\frac{\\left\\vert\nA\\right\\vert}{2}\\)。\n推论\\(\\quad\\)\n如果在 \\(x_0\\) 的某去心邻域内 \\(f(x) \\ge 0\\)（或 \\(f(x) \\le 0\\)），而且 \\(\\lim\\limits_{x\\to x_0}f(x) = A\\)，那么\n\\(A \\ge 0\\)（或 \\(A \\le 0\\)）。\n定理 \\(4\\)（函数极限与数列极限的关系）\\(\\quad\\) 如果极限 \\(\\lim\\limits_{x \\to x_0}f(x)\\) 存在，\\(\\{x_n\\}\\) 为函数 \\(f(x)\\) 的定义域内任一收敛于 \\(x_0\\) 的数列，且满足：\\(x_n \\ne x_0\\)（\\(n \\in N_+\\)），那么相应的函数值数列 \\(\\{f(x_n)\\}\\) 必收敛，且 \\(\\lim\\limits_{n \\to \\infty}f(x_n) = \\lim\\limits_{x\n\\to x_0}f(x)\\)。\n无穷小\n定义\n如果函数 \\(f(x)\\) 当 \\(x \\to x_0\\)（或 \\(x \\to \\infty\\)）时的极限为零，那么称函数\n\\(f(x)\\) 为当 \\(x \\to x_0\\)（或 \\(x \\to \\infty\\)）时的无穷小。 ## 性质\n在自变量的同一变化过程 \\(x \\to\nx_0\\)（或 \\(x \\to\n\\infty\\)）中，函数 \\(f(x)\\)\n具有极限 \\(A\\) 的充分必要条件时 \\(f(x) = A + \\alpha\\)，其中 \\(\\alpha\\) 是无穷小。 ## 比较 如果 \\(\\lim\\frac{\\beta}{\\alpha} = 0\\)，那么就说\n\\(\\beta\\) 是比 \\(\\alpha\\)\n高阶的无穷小，记作 \\(\\beta =\no(\\alpha)\\)\n如果 \\(\\lim\\frac{\\beta}{\\alpha} =\n\\infty\\)，那么就说 \\(\\beta\\)\n是比 \\(\\alpha\\)\n低阶的无穷小\n如果 \\(\\lim\\frac{\\beta}{\\alpha} = c \\ne\n0\\)，那么就说 \\(\\beta\\) 与 \\(\\alpha\\)\n是同阶的无穷小\n如果 \\(\\lim\\frac{\\beta}{\\alpha^k} = c \\ne\n0, k &gt; 0\\)，那么就说 \\(\\beta\\) 是关于 \\(\\alpha\\) 的 \\(k\\) 阶的无穷小\n如果 \\(\\lim\\frac{\\beta}{\\alpha} =\n1\\)，那么就说 \\(\\beta\\) 与 \\(\\alpha\\)\n是等价无穷小，记作 \\(\\alpha\n\\sim \\beta\\)\n定理 \\(1\\quad\\)\n\\(\\beta\\) 与 \\(\\alpha\\) 是等价无穷小的充分必要条件为 \\[\n\\beta = \\alpha + o(\\alpha)\n\\]\n定理 \\(2\\quad\\) 设\n\\(\\alpha \\sim \\tilde\\alpha\\)，\\(\\beta \\sim \\tilde\\beta\\)，且 \\(\\lim\\limits\\frac{\\tilde\\beta}{\\tilde\\alpha}\\)\n存在，则 \\[\n\\lim\\limits\\frac{\\beta}{\\alpha} =\n\\lim\\limits\\frac{\\tilde\\beta}{\\tilde\\alpha}\n\\] # 无穷大 ## 定义 设函数 \\(f(x)\\) 在 \\(x_0\\) 的某一去心邻域内有定义（或 \\(\\left\\vert x \\right\\vert\\)\n大于某一正数时有定义）。如果对于任意给定的正数 \\(M\\)（不论它有多大），总存在正数 \\(\\delta\\)（或正数 \\(X\\)），只要 \\(x\\) 适合不等式 \\(0 &lt; \\left\\vert x - x_0 \\right\\vert &lt;\n\\delta\\)（或 \\(\\left\\vert x \\right\\vert\n&gt; X\\)），对应的函数值 \\(f(x)\\) 总满足不等式 \\[\n\\left\\vert f(x) \\right\\vert &gt; M\n\\] 那么称函数 \\(f(x)\\) 是当\n\\(x \\to x_0\\)（或 \\(x \\to \\infty\\)）时的无穷大。\n性质\n在自变量的同一变化过程中，如果 \\(f(x)\\) 为无穷大，那么 \\(\\frac{1}{f(x)}\\) 为无穷小；反之，如果 \\(f(x)\\) 为无穷小，且 \\(f(x) \\ne 0\\)，那么 \\(\\frac{1}{f(x)}\\) 为无穷大。\n极限运算法则\n定理 \\(1\\quad\\)\n有限个无穷小的和是无穷小\n定理 \\(2\\quad\\)\n有界函数与无穷小的乘积是无穷小\n推论 \\(1\\quad\\)\n常数与无穷小的乘积是无穷小\n推论 \\(2\\quad\\)\n有限个无穷小的乘积是无穷小\n定理 \\(3\\quad\\)\n如果 \\(\\lim f(x)=A, \\lim g(x) =\nB\\)，那么\n\n\\(\\lim\\left[f(x) \\pm g(x) \\right] = \\lim\nf(x) \\pm \\lim g(x) = A \\pm B\\)\n\\(\\lim\\left[f(x) \\cdot g(x) \\right] = \\lim\nf(x) \\cdot \\lim g(x) = A \\cdot B\\)\n若又有 \\(B \\ne 0\\)，则\n\n\\[\n\\lim \\frac{f(x)}{g(x)} = \\frac{\\lim f(x)}{\\lim g(x)} = \\frac{A}{B}\n\\]\n定理 \\(4\\quad\\)\n设有数列 \\(\\{x_n\\}\\) 和 \\(\\{y_n\\}\\)。如果 \\[\n\\lim\\limits_{n\\to\\infty}x_n = A,\\quad \\lim\\limits_{n\\to\\infty}y_n = B\n\\] 那么 1. \\(\\lim\\limits_{n\\to\\infty}(x_n\\pm y_n) = A \\pm\nB\\) 2. \\(\\lim\\limits_{n\\to\\infty}(x_n\n\\cdot y_n) = A \\cdot B\\) 3. 当 \\(y_n\n\\ne 0\\)（\\(n = 1, 2,\n\\cdots\\)）且 \\(B \\ne 0\\)\n时，\\(\\lim\\limits_{n\\to\\infty}\\frac{x_n}{y_n}\n= \\frac{A}{B}\\)\n定理 \\(5\\quad\\)\n如果 \\(\\varphi(x) \\ge \\psi(x)\\)，而\n\\(\\lim\\limits \\varphi(x) = A\\)，\\(\\lim\\limits \\psi(x) = B\\)，那么 \\(A \\ge B\\)。\n定理 \\(6\\)（复合函数的极限运算法则）\\(\\quad\\) 设函数 \\(y = f\\left[g(x)\\right]\\) 是由函数 \\(u = g(x)\\) 与函数 \\(y = f(u)\\) 复合而成，\\(f\\left[g(x)\\right]\\) 在点 \\(x_0\\) 的某去心邻域内有定义，若 \\(\\lim\\limits_{x\\to x_0}g(x) = u_0\\)，\\(\\lim\\limits_{u \\to u_0}f(u) = A\\)，且存在\n\\(\\delta_0 &gt; 0\\)，当 \\(x \\in \\mathring{U}(x_0, \\delta_0)\\) 时，有\n\\(g(x) \\ne u_0\\)，则 \\[\n\\lim\\limits_{x \\to x_0}f\\left[g(x)\\right] = \\lim\\limits_{u\\to u_0}f(u) =\nA\n\\]\n极限存在准则\n准则 \\(\\mathrm{I}\\quad\\) 如果数列 \\(\\{x_n\\}\\)，\\(\\{y_n\\}\\) 及 \\(\\{z_n\\}\\) 满足下列条件： 1. 从某项起，即\n\\(\\exists n_0 \\in \\mathbb{N}^+\\)，当\n\\(n &gt; n_0\\) 时，有 \\[\ny_n \\le x_n \\le z_n\n\\] 2. \\(\\lim\\limits_{n \\to \\infty}y_n =\na, \\lim\\limits_{n\\to\\infty}z_n = a\\)\n那么数列 \\(\\{x_n\\}\\) 的极限存在，且\n\\(\\lim\\limits_{n\\to\\infty}x_n = a\\)\n准则 \\(\\mathrm{I}^\\prime\\quad\\) 如果 1.\n当 \\(x \\in \\mathring{U}(x_0, r)\\)（或\n\\(\\left\\vert x \\right\\vert &gt;\nM\\)）时，\n\\[\ng(x) \\le f(x) \\le h(x)\n\\]\n\n\\(\\lim\\limits_{x\\to x_0 \\atop (x \\to\n\\infty)}g(x) = A, \\lim\\limits_{x\\to x_0 \\atop (x\\to\\infty)}h(x) =\nA\\)\n\n那么 \\(\\lim\\limits_{x\\to x_0 \\atop (x\\to\n\\infty)}f(x)\\) 存在，且等于 \\(A\\)。\n准则 \\(\\mathrm{I}\\) 及准则 \\(\\mathrm{I}^\\prime\\)\n称为夹逼准则。\n准则 \\(\\mathrm{II}\\quad\\)\n单调有界数列必有极限。\n"},{"title":"矩阵","url":"/2024/03/12/Matrix/","content":"分块矩阵\n加法\n设 \\(A=\\begin{pmatrix}A_{11}&amp;\\cdots&amp;A_{1t}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{s1}&amp;\\cdots&amp;A_{st}\\end{pmatrix}\\)，\n\\(B =\n\\begin{pmatrix}B_{11}&amp;\\cdots&amp;B_{1t}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\B_{s1}&amp;\\cdots&amp;B_{st}\\end{pmatrix}\\)，则\n\\[A + B = \\begin{pmatrix}A_{11} +\nB_{11}&amp;\\cdots&amp;A_{1t}+B_{1t}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{s1}+B_{s1}&amp;\\cdots&amp;A_{st}+B_{st}\\end{pmatrix}\\]\n数乘\n设 \\(A=\\begin{pmatrix}A_{11}&amp;\\cdots&amp;A_{1t}\\\\\n\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{s1}&amp;\\cdots&amp;A_{st}\\end{pmatrix}\\)，则\n\\[kA =\n\\begin{pmatrix}kA_{11}&amp;\\cdots&amp;kA_{1t}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\kA_{s1}&amp;\\cdots&amp;kA_{st}\\end{pmatrix}\\]\n乘法\n设 \\(A=\\begin{pmatrix}A_{11}&amp;\\cdots&amp;A_{1t}\\\\\n\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{s1}&amp;\\cdots&amp;A_{st}\\end{pmatrix}\\)，\\(B =\n\\begin{pmatrix}B_{11}&amp;\\cdots&amp;B_{1r}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\B_{t1}&amp;\\cdots&amp;B_{tr}\\end{pmatrix}\\)，则\n\\[AB =\n\\begin{pmatrix}C_{11}&amp;\\cdots&amp;C_{1r}\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\C_{s1}&amp;\\cdots&amp;C_{sr}\\end{pmatrix}\\]\n其中 \\(C_{ij}=\\sum_{k=1}^tA_{ik}B_{kj}\\)\n幂\n设 \\(A = \\begin{pmatrix} A_1 &amp; &amp;\n&amp; \\\\ &amp; A_2 &amp; &amp; \\\\ &amp; &amp; \\ddots &amp;\\\\ &amp; &amp;\n&amp; A_s \\end{pmatrix}\\)，则 \\[ A^m =\n\\begin{pmatrix}\nA_1^m &amp; &amp; &amp;\\\\\n&amp; A_2^m &amp; &amp;\\\\\n&amp; &amp; \\ddots &amp;\\\\\n&amp; &amp; &amp; A_s^m\\\\\n\\end{pmatrix}\\]\n转置\n设 \\(A=\\begin{pmatrix}A_{11}&amp;A_{12}&amp;\\cdots&amp;A_{1t}\\\\A_{21}&amp;A_{22}&amp;\\cdots&amp;A_{2t}\\\\\n\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{s1}&amp;A_{s2}&amp;\\cdots&amp;A_{st}\\end{pmatrix}\\)，则\n\\[A&#39; =\n\\begin{pmatrix}A_{11}^\\prime&amp;A_{21}^\\prime&amp;\\cdots&amp;A_{s1}^\\prime\\\\A_{12}^\\prime&amp;A_{22}^\\prime&amp;\\cdots&amp;A_{s2}^\\prime\\\\\n\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{1t}^\\prime&amp;A_{2t}^\\prime&amp;\\cdots&amp;A_{st}^\\prime\\end{pmatrix}\\]\n行列式\n\\[\\begin{vmatrix}\nA_{11} &amp;A_{12} &amp;\\cdots &amp;A_{1s}\\\\\n0 &amp;A_{22} &amp;\\cdots &amp;A_{2s}\\\\\n\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots\\\\\n0 &amp;0 &amp;\\cdots &amp;A_{ss}\n\\end{vmatrix} = \\left\\vert A_{11}\\right\\vert \\left\\vert\nA_{22}\\right\\vert\\cdots\\left\\vert A_{ss}\\right\\vert\\]\n\\[\\begin{vmatrix}\nA_{11} &amp; 0 &amp; \\cdots &amp; 0\\\\\nA_{21} &amp; A_{22} &amp; \\cdots &amp; 0\\\\\n\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots\\\\\nA_{s1} &amp; A_{s2} &amp; \\cdots &amp; A_{ss}\n\\end{vmatrix} = \\left\\vert A_{11}\\right\\vert \\left\\vert\nA_{22}\\right\\vert\\cdots\\left\\vert A_{ss}\\right\\vert\\]\n\\[\\begin{vmatrix}\nA_{1} &amp; &amp; &amp; \\\\\n&amp; A_{2} &amp; &amp; \\\\\n&amp; &amp; \\ddots &amp; \\\\\n&amp; &amp; &amp; A_{s}\n\\end{vmatrix} = \\left\\vert A_{1}\\right\\vert \\left\\vert\nA_{2}\\right\\vert\\cdots\\left\\vert A_{s}\\right\\vert\\]\n逆\n\\[ \\begin{pmatrix}\nA_1 &amp; &amp; &amp;\\\\\n&amp; A_2 &amp; &amp;\\\\\n&amp; &amp; \\ddots &amp;\\\\\n&amp; &amp; &amp;A_s\n\\end{pmatrix}^{-1} =\n\\begin{pmatrix}\nA_1^{-1} &amp; &amp; &amp;\\\\\n&amp; A_2^{-1} &amp; &amp;\\\\\n&amp; &amp; \\ddots &amp;\\\\\n&amp; &amp; &amp;A_s^{-1}\n\\end{pmatrix}\\]\n\\[ \\begin{pmatrix}\n&amp; &amp; &amp;A_1 \\\\\n&amp; &amp; A_2 &amp;\\\\\n&amp;\\ddots &amp; &amp;\\\\\nA_s&amp; &amp; &amp;\n\\end{pmatrix}^{-1} =\n\\begin{pmatrix}\n&amp; &amp; &amp;A_s^{-1}\\\\\n&amp;&amp; A_{s-1}^{-1} &amp;\\\\\n&amp; \\ddots &amp;&amp; \\\\\nA_1^{-1}&amp; &amp; &amp;\n\\end{pmatrix}\\] # 降阶公式 设 \\(A\\) 为 \\(m\\times\nn\\) 矩阵，\\(B\\) 是 \\(n\\times m\\) 矩阵，\\(m&gt;n\\)，\\(\\lambda\\) 是任意数，则 \\[\\left\\vert\\lambda E_m - AB\\right\\vert =\n\\lambda^{m-n}\\left\\vert\\lambda E_n - BA\\right\\vert\\]\n矩阵的秩\n定义\n矩阵 \\(A\\)\n的非零子式的最高阶数叫作矩阵 \\(A\\)\n的秩。\n性质\n设 \\(A\\) 为 \\(m\\times n\\) 矩阵，\\(B\\) 为 \\(n\\times\np\\) 矩阵，则 - \\(0 \\le R(A) \\le\n\\min\\{m, n\\}\\) - \\(R(A&#39;) =\nR(A)\\) - \\(R(kA) =\n\\begin{cases}0&amp;k=0\\\\R(A)&amp;k\\ne0\\end{cases}\\) - \\(R(A_1) \\le R(A)\\)，其中 \\(A_1\\) 为 \\(A\\) 的任意一个子矩阵。 - \\(R\\begin{pmatrix}A&amp;0\\\\0&amp;B\\end{pmatrix} =\nR(A) + R(B)\\) - \\(R\\begin{pmatrix}A&amp;C\\\\0&amp;B\\end{pmatrix} \\ge\nR(A) + R(B)\\) - \\(R(A \\mid B) \\le R(A)\n+ R(B)\\) - \\(R(A + B) \\le R(A) +\nR(B)\\) - \\(R(AB) \\le \\min\\{R(A),\nR(B)\\}\\) - \\(R(AB) \\ge R(A) + R(B) -\nn\\)\n","tags":["Math","Linear Algebra"]},{"title":"多元函数","url":"/2024/03/05/Mulifunction/","content":"多元函数的基本概念\nN 维空间\n称有序数组 \\((x_1, x_2, \\cdots,\nx_n)\\) 为一个 \\(n\\)\n维点（\\(n\\) 维向量）。所有\n\\(n\\) 维点组成的集合称之为\n\\(n\\) 维空间，记为\n\\(\\mathbb{R}^n\\)。\nN 维空间的距离\n设 \\(A(x_1, x_2, \\cdots, x_n)\\) 和\n\\(B(y_1, y_2, \\cdots, y_n)\\) 为 \\(\\mathbb{R}^n\\) 空间上任意两点，称 \\[\n\\rho(A, B) = \\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + \\cdots + (x_n -\ny_n)^2}\n\\] 为 \\(A, B\\)\n两点间的距离。\n邻域\n设 \\(\\alpha = (a_1, a_2, \\cdots, a_n) \\in\n\\mathbb{R}^n\\)，\\(\\delta\\)\n是某一正数，则 \\(n\\) 维空间内的点集\n\\[\nU(a, \\delta) = \\{x|x\\in \\mathbb{R}^n, \\rho(x, a) &lt; \\delta\\}\n\\] 就定义为 \\(\\mathbb{R}^n\\)\n中点 \\(a\\) 的 \\(\\delta\\) 邻域。\n记 \\(\\mathring{U}(a, \\delta)\\)\n为不含 \\(a\\)\n点的去心邻域。\n内点、界点和聚点\n\n内点：设 \\(D \\subset\n\\mathbb{R}^n\\)，\\(P_0 \\in\n\\mathbb{R}^n\\)，若存在 \\(P_0\\)\n的一个邻域使此邻域属于 \\(D\\)，称 \\(P_0\\) 为 \\(D\\) 的内点。\n界点：设 \\(D \\subset\n\\mathbb{R}^n\\)，\\(P_0 \\in\n\\mathbb{R}^n\\)，若对 \\(P_0\\)\n的任何邻域总有 \\(D\\) 中的点且总有 \\(D\\) 外的点，则称 \\(P_0\\) 为 \\(D\\) 的界点。\n聚点：\\(\\forall \\delta &gt;\n0\\)，点 \\(P_0\\) 的去心邻域 \\(\\mathring{U}(P_0, \\delta)\\) 中总有 \\(D\\) 中的无穷多个点，称 \\(P_0\\) 为集合 \\(D\\) 的一个聚点。\n\n其他\n\n边界：界点的全体称为 \\(D\\)\n的边界。\n开集：由全部内点组成的集合称为开集。\n开区域：连通的开集称为开区域。\n闭区域：开区域 + 边界 =\n闭区域。\n有界集：对平面点集 \\(E\\)，若 \\(\\exists r &gt; 0\\)，\\(E \\subset U(O, r)\\)，\\(O\\) 为坐标原点，称 \\(E\\) 为有界集。 #\n多元函数的极限\n\n定义\n设 \\(z = f(P) = f(x, y)\\) 在 \\(D\\) 上有定义，\\(P_0(x_0, y_0)\\) 为 \\(D\\) 的一聚点，\\(A\\) 是一实数，若对 \\(\\forall \\varepsilon &gt; 0\\)，存在 \\(\\delta &gt; 0\\)，使得当 \\(0 &lt; \\rho(P, P_0) &lt; \\delta\\) 时，恒有\n\\[\n\\left\\vert f(P) - A \\right\\vert = \\left\\vert f(x, y) - A \\right\\vert\n&lt; \\varepsilon\n\\] 则称二元函数 \\(f(x, y)\\) 在点\n\\(P_0\\)\n处有二重极限。\n记 \\(\\lim\\limits_{P \\to P_0} f(P) =\n\\lim\\limits_{(x, y) \\to (x_0, y_0)} f(x, y) = \\lim\\limits_{x \\to x_0\n\\atop y \\to y_0} f(x, y) = A\\)\n性质\n\\(\\lim\\limits_{x \\to x_0 \\atop y \\to y_0}\nf(x, y)\\) 存在 \\(\\Leftrightarrow\\) 点 \\(P(x, y)\\) 沿任何方向、任何路径趋向于 \\(P_0(x_0, y_0)\\) 时，极限都存在且相等。\n连续\n定义\n设 \\((x_0, y_0)\\) 是 \\(D\\) 的聚点，\\(z =\nf(x, y)\\) 在 \\(D\\) 上有定义，且\n\\(\\lim\\limits_{x \\to x_0 \\atop y \\to y_0} f(x,\ny) = f(x_0, y_0)\\) 或 \\(\\lim\\limits_{\\Delta x \\to 0 \\atop \\Delta y \\to\n0}\\left[f(x_0 + \\Delta x, y_0 + \\Delta y) - f(x_0, y_0)\\right] =\n0\\)，则称 \\(f(x, y)\\) 在点 \\((x_0, y_0)\\) 处连续。\n性质\n反函数性质去掉，其他的和一元函数相同。\n偏导数\n定义\n设 \\(z = f(x,y)\\) 在 \\((x_0, y_0)\\) 邻域内有定义，固定 \\(y= y_0\\)，若极限 \\(\\lim\\limits_{x\\to x_0} \\frac{f(x,y_0) - f(x_0,\ny_0)}{x-x_0} = \\lim\\limits_{\\Delta x\\to 0} \\frac{f(x_0 + \\Delta x, y_0)\n- f(x_0, y_0)}{\\Delta x}\\) 存在，则称 \\(f(x,y)\\) 在点 \\((x_0, y_0)\\) 处关于 \\(x\\) 的偏导数存在。\n记为 \\(z&#39;_x \\Big| _{x=x_0\\atop y=y_0} =\nf&#39;_x(x_0, y_0) = f&#39;_1(x_0, y_0) = \\frac{\\partial z}{\\partial\nx}\\Big|_{(x_0,y_0)}\\)\n同样定义\n\\[\n\\begin{split}\n    \\lim\\limits_{y\\to y_0} \\frac{f(x_0,y) - f(x_0, y_0)}{y-y_0} =\n\\lim\\limits_{\\Delta y\\to 0} \\frac{f(x_0 , y_0+ \\Delta y) - f(x_0,\ny_0)}{\\Delta y} \\\\\n    = z&#39;_y \\Big| _{x=x_0\\atop y=y_0} = f&#39;_y(x_0, y_0) =\nf&#39;_2(x_0, y_0) = \\frac{\\partial z}{\\partial y}\\Big|_{(x_0,y_0)}\n\\end{split}\n\\]\n设 \\(z=f(x,y)\\) 在 \\(D\\) 上每一点都有偏导，则其偏导又是 \\(D\\) 上一个新的二元函数——称之为 \\(f(x,y)\\) 在 \\(D\\) 上的偏导（函）数。\n记为 \\(z&#39;_x = f&#39;_x = f&#39;_1 =\n\\frac{\\partial z}{\\partial x}\\)；\\(z&#39;_y = f&#39;_y = f&#39;_2 = \\frac{\\partial\nz}{\\partial y}\\)。\n几何意义\n\\(f&#39;_x(x_0, y_0)\\) 表示曲线\n\\(\\begin{cases}  y = y_0 \\\\  z = f(x,y)\n\\end{cases}\\) 在点 \\((x_0, y_0, f(x_0,\ny_0))\\) 处切线的斜率。\n性质\n若 \\(z = f(x,y)\\) 的二阶混合偏导数\n\\(f&#39;&#39;_{xy}, f_{yx}&#39;&#39;\\)\n都存在且连续，则 \\(f&#39;&#39;_{xy} =\nf_{yx}&#39;&#39;\\)。\n全微分\n定义\n设 \\(z = f(x,y)\\) 在 \\((x_0, y_0)\\) 邻域内有定义，\\(f(x,y)\\) 的全增量 \\(\\Delta z = f(x_0 + \\Delta x, y_0 + \\Delta y) -\nf(x_0, y_0)\\) 可表示为 \\(\\Delta z = A\n\\Delta x + B \\Delta y + o(\\rho)\\)，其中 \\(A, B\\) 为常数，\\(\\rho = \\sqrt{(\\Delta x)^2 + (\\Delta\ny)^2}\\)，则称 \\(f(x,y)\\) 在点\n\\((x_0, y_0)\\)\n处可微，并称 \\(A\\Delta x +\nB\\Delta y\\) 为 \\(f(x,y)\\) 在点\n\\((x_0, y_0)\\)\n处的全微分。\n记为 \\(dz\\)，即 \\(dz = A\\Delta x + B\\Delta y = Adx +\nBdy\\)\n性质\n\n设 \\(z = f(x,y)\\) 在 \\((x_0, y_0)\\) 点可微，则 \\(f(x,y)\\) 在 \\((x_0, y_0)\\) 点处连续。\n设 \\(z = f(x,y)\\) 在 \\((x_0, y_0)\\) 点可微，则 \\(f(x,y)\\) 在 \\((x_0, y_0)\\) 点处两个偏导数 \\(f&#39;_x(x_0, y_0), f&#39;_y(x_0, y_0)\\)\n都存在，且 \\[\ndz \\Big|_{x=x_0\\atop y=y_0} = f&#39;_x(x_0, y_0)dx + f&#39;_y(x_0,\ny_0)dy\n\\]\n设 \\(z = f(x,y)\\) 在 \\((x_0, y_0)\\) 点偏导数 \\(f&#39;_x(x_0, y_0), f&#39;_y(x_0, y_0)\\)\n都存在，且这两个偏导又在点 \\((x_0,\ny_0)\\) 处连续，则 \\(f(x,y)\\) 在\n\\((x_0, y_0)\\) 点可微。\n\n几何意义\n\\(z = f(x_0, y_0) + f&#39;_x(x_0,\ny_0)(x-x_0) + f&#39;_y(x_0, y_0)(y-y_0)\\) 是一个平面。\n该平面是过曲线 \\(\\begin{cases}  x = x_0\n\\\\  z = f(x,y) \\end{cases}\\) 和 \\(\\begin{cases}  y = y_0 \\\\  z = f(x,y)\n\\end{cases}\\) 在点 \\((x_0, y_0, f(x_0,\ny_0))\\) 处两切线的平面。\n复合函数\n链式法则\n设 \\(z = f(u, v)\\) 可微，而 \\(u = \\varphi(x,y),v=\\psi(x,y)\\) 偏导存在，则\n\\(z\\) 关于 \\(x\\) 和 \\(y\\) 的偏导数存在，且 \\[\n    \\frac{\\partial z}{\\partial x} = \\frac{\\partial z}{\\partial u} \\cdot\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial z}{\\partial v} \\cdot\n\\frac{\\partial v}{\\partial x} = f&#39;_u\\varphi&#39;_x + f&#39;_v\n\\psi&#39;_x\n\\] \\[\n    \\frac{\\partial z}{\\partial x} = \\frac{\\partial z}{\\partial u} \\cdot\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial z}{\\partial v} \\cdot\n\\frac{\\partial v}{\\partial x} = f&#39;_u\\varphi&#39;_x + f&#39;_v\n\\psi&#39;_x\n\\]\n全微分\n设 \\(z =\nf(u,v),u=\\varphi(x,y),v=\\psi(x,y)\\) 均可微，则不论将 \\(z\\) 看成 \\((u,z)\\) 的函数还是 \\((x,y)\\)\n的函数，其微分形式不变，即 \\[\ndz = \\frac{\\partial z}{\\partial u} du + \\frac{\\partial z}{\\partial v} dv\n= \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy\n\\]\n隐函数\n隐函数存在的微分法则\n设 \\(F(x,y)\\) 是 \\((x_0,y_0)\\) 邻域内满足 1. \\(F(x_0,y_0) = 0\\) 2. \\(F&#39;_x(x,y),F&#39;_y(x,y)\\) 连续 3. \\(F&#39;_y(x_0,y_0)\\ne 0\\)\n则方程 \\(F(x,y)=0\\) 在 \\((x_0,y_0)\\) 邻域内能唯一确定 \\(y=f(x)\\)，且此函数连续可导，而 \\(\\frac{dy}{dx} =\n-\\frac{F&#39;_x(x,y)}{F&#39;_y(x,y)}\\)\n推广\n设 \\(F(x,y,z)\\) 是 \\((x_0,y_0,z_0)\\) 邻域内满足 1. \\(F(x_0, y_0, z_0) = 0\\) 2. \\(F&#39;_x(x,y,z),F&#39;_y(x,y,z),F&#39;_z(x,y,z)\\)\n连续 3. \\(F&#39;_z(x_0,y_0,z_0) \\ne\n0\\)\n则方程 \\(F(x,y,z) = 0\\) 在 \\((x_0,y_0,z_0)\\) 邻域唯一确定一个单值函数\n\\(z=f(x,y)\\)，且此函数连续可导，而\n\\[\n\\frac{\\partial z}{\\partial x} =\n-\\frac{F&#39;_x}{F&#39;_z},\\frac{\\partial z}{\\partial y} =\n-\\frac{F&#39;_y}{F&#39;_z}\n\\]\n方程组确定隐函数\n存在准则\n略，不常用且难记。\n前置芝士\n\\(n\\) 个方程，\\(m\\) 个变量组成方程组（\\(m&gt;n\\)）能确定 \\(n\\) 个 \\(m-n\\) 元函数。\n解法\n求解的时候判断是一元函数还是多元函数，一元函数就求导，多元函数就求偏导，最后解方程组即可求出答案。\n极值\n二元函数的 Taylor 公式\n若 \\(f(x,y)\\) 在 \\((x_0,y_0)\\) 邻域内有 \\(n+1\\) 阶连续偏导数，则称 \\[\nf(x_0 + \\Delta x, y_0 + \\Delta y) = f(x_0, y_0) +\n\\frac{1}{1!}\\left(\\Delta x\\frac{\\partial}{\\partial x} + \\Delta y\n\\frac{\\partial}{\\partial y}\\right)f(x_0, y_0) + \\frac{1}{2!}\\left(\\Delta\nx\\frac{\\partial}{\\partial x} + \\Delta y \\frac{\\partial}{\\partial\ny}\\right)^2f(x_0, y_0) + \\cdots + \\frac{1}{n!}\\left(\\Delta\nx\\frac{\\partial}{\\partial x} + \\Delta y \\frac{\\partial}{\\partial\ny}\\right)^nf(x_0, y_0) + \\frac{1}{(n+1)!}\\left(\\Delta\nx\\frac{\\partial}{\\partial x} + \\Delta y \\frac{\\partial}{\\partial\ny}\\right)^{n+1}f(x_0+\\theta\\Delta x, y_0+\\theta\\Delta y),\\theta \\in\n(0,1)\n\\] 为 \\(f(x,y)\\) 在 \\((x_0, y_0)\\) 点处 \\(n\\) 阶 Taylor 公式。\n二元函数极值\n设 \\(z=f(x,y)\\) 在 \\((x_0,y_0)\\) 邻域内有连续二阶偏导，且 \\[\nf&#39;_x(x_0,y_0) = f&#39;_y(x_0,y_0) = 0\n\\] 令 \\(A = f&#39;&#39;_{xx}(x_0, y_0),\nB=f&#39;&#39;_{xy}(x_0,y_0),C=f&#39;&#39;_{yy}(x_0,y_0)\\) 1. 当\n\\(\\Delta = B^2 - AC &gt;0\\) 时，\\(f(x_0,y_0)\\) 不是极值； 2. 当 \\(\\Delta = B^2 - AC &lt; 0\\)时，\\(f(x_0,y_0)\\) 是极值。 - 若 \\(A&gt;0\\)（或 \\(C&gt;0\\)）时，\\(f(x_0,y_0)\\) 是极小值； - 若 \\(A&lt;0\\)（或 \\(C&lt;0\\)）时，\\(f(x_0,y_0)\\) 是极大值。\n条件极值\n定义\n若 \\(z = f(x,y)\\) 为 \\(D\\) 上的二元函数，求 \\(z=f(x,y)\\) 在 \\(D\\) 上满足条件 \\(g(x,y)=0\\)\n的极值称之为函数的条件极值。\n拉格朗日乘数法\n设 \\(f(x_1,x_2,\\cdots,x_n)\\) 为\n\\(D\\) 上 \\(n\\) 元函数，\\(g_i(x_1, x_2, \\cdots, x_n)=0\\)（\\(i = 1,2,\\cdots,m\\) 且 \\(m &lt; n\\)）是 \\(D\\) 上 \\(m\\) 个条件，则 \\(f\\) 在这 \\(m\\) 个条件下极值（驻点）等价于（\\(m+n\\)）元函数 \\[\nF(x_1,x_2,\\cdots,x_n,\\lambda_1,\\lambda_2,\\cdots,\\lambda_m) =\nf(x_1,x_2,\\cdots,x_n) + \\sum\\limits_{i=1}^m\n\\lambda_ig_i(x_1,x_2,\\cdots,x_n)\n\\] 的无条件极值（驻点）。\n关系图\n\n\n\n\n连续\n偏导\n可微\n方向导数\n\n\n\n\n连续\n√\n×\n×\n×\n\n\n偏导\n×\n√\n×\n×\n\n\n可微\n√\n√\n√\n√\n\n\n方向导数\n×\n×\n×\n√\n\n\n\n","tags":["Math","Calculus"]},{"title":"幂级数","url":"/2024/03/01/Power-Series/","content":"函数项级数\n定义\n设 \\(f_n(x)\\) 是定义在 \\(D\\) 上的一串函数（\\(n = 1, 2, 3,\n\\cdots\\)），也称之为函数序列，用 +\n号将其一次连接起来，\\(f_1(x) + f_2(x) + \\cdots\n+ f_n(x) + \\cdots \\triangleq \\sum\\limits_{n=1}^\\infty f_n(x)\\)\n称之为 \\(D\\)\n上的函数项级数。\\(S_n =\nf_1(x) + f_2(x) + \\cdots + f_n(x)\\)\n称为部分和。\\(r_n(x) =\nf_{n+1}(x) + f_{n+2}(x) + \\cdots\\)\n为函数项级数的余项。\n对 \\(x_0 \\in D\\)，若 \\(\\sum\\limits_{n=1}^\\infty f_n(x_0)\\)\n收敛，则称 \\(x_0\\) 为 \\(\\sum\\limits_{n=1}^\\infty f_n(x)\\)\n的收敛点，收敛点的全体组成的集合称为 \\(\\sum\\limits_{n=1}^\\infty f_n(x)\\)\n的收敛域，记 \\(S(x) =\n\\lim\\limits_{n\\to\\infty} S_n(x)\\)，称 \\(S(x)\\)\n为函数项级数的和函数。\n性质\n定理1\\(\\quad\\) 函数项级数和函数的连续性\n设 \\(\\sum\\limits_{n=1}^\\infty\nu_n(x)\\) 在 \\([a, b]\\)\n上一致收敛，且级数每一项 \\(u_n(x)\\) 在\n\\([a, b]\\) 上都连续，则和函数 \\(S(x)\\) 在 \\([a,\nb]\\) 上连续。\n定理2\\(\\quad\\) 函数项级数逐项积分性\n定理3\\(\\quad\\) 函数项级数逐项微分性\n幂级数\n定义\n称 \\(\\sum\\limits_{n=0}^\\infty a_n x^n = a_0\n+ a_1 x + \\cdots + a_n x^n + \\cdots\\)\n为标准的幂级数，这里 \\(a_n\\)，\\(n = 0,\n1, 2, \\cdots\\) 称之为幂级数的系数。\n称 \\(\\sum\\limits_{n=0}^\\infty a_n (x-x_0)^n\n= a_0 + a_1(x-x_0) + \\cdots + a_n(x-x_0)^n + \\cdots\\)\n为一般型幂级数。\n称 \\(\\sum\\limits_{n=0}^\\infty a_n\n\\phi^n(x)\\) 为广义幂级数。\n对于 \\(\\sum\\limits_{n=0}^\\infty a_n\nx^n\\)，当 \\(x=0\\)\n时，级数收敛，若除 \\(0\\)\n以外没有收敛点称为级数发散。\n任何一个标准的幂级数 \\(\\sum\\limits_{n=0}^\\infty a_n\nx^n\\)，都存在唯一一个 \\(R\\)，\\((R \\ge 0\n或 R = +\\infty)\\) 使 \\(\\sum\\limits_{n=0}^\\infty a_n x^n\\) 在 \\((-R, R)\\) 内绝对收敛，在 \\((-\\infty, -R)\\) 和 \\((R, +\\infty)\\) 上发散，则称 \\(R\\) 为 \\(\\sum\\limits_{n=0}^\\infty a_n x^n\\)\n的收敛半径，\\((-R,\nR)\\) 称之为 \\(\\sum\\limits_{n=0}^\\infty\na_n x^n\\) 的收敛区间。\n\\(\\sum\\limits_{n=0}^\\infty a_n x^n\\)\n的收敛域 \\(=\\)\n收敛区间 \\((-R, R) \\cup \\pm R\\)\n中收敛的点\n性质\n设 \\(\\sum\\limits_{n=0}^\\infty a_n\nx^n\\) 在 \\(x_0 \\ne 0\\)\n点收敛，则 \\(\\sum\\limits_{n=0}^\\infty a_n\nx^n\\) 在 \\(\\vert x\\vert &lt; \\vert x_0\n\\vert\\) 上绝对收敛。\n推论：如果 \\(\\sum\\limits_{n=0}^\\infty a_n x^n\\) 在 \\(x_0\\) 点发散，则 \\(\\sum\\limits_{n=0}^\\infty a_n x^n\\) 在 \\(\\vert x\\vert &gt; \\vert x_0\\vert\\)\n上发散。\n设 \\(\\sum\\limits_{n=0}^\\infty a_n\nx^n\\) 满足 \\(\\lim\\limits_{n\\to\\infty}\n\\left\\vert \\frac{a_{n+1}}{a_n}\\right\\vert\\) （或 \\(\\lim\\limits_{n\\to\\infty} \\sqrt[n]{\\vert\na_n\\vert}\\)）\\(= \\rho \\ge\n0\\)（或 \\(+\\infty\\)），则 \\(R = \\frac{1}{\\rho}\\) 是 \\(\\sum\\limits_{n=0}^\\infty a_n x^n\\)\n的收敛半径。\n","tags":["Math","Series"]},{"title":"二次型","url":"/2024/03/07/Quadratic-Form/","content":"合同矩阵\n定义\n给定两个 \\(n\\) 阶方阵 \\(A\\) 和 \\(B\\)，如果存在可逆矩阵 \\(C\\)，使得 \\[\nB = C^\\prime A C\n\\]\n则称 \\(A\\) 和 \\(B\\) 合同。\n性质\n\n自反性：任一 \\(n\\) 阶方阵 \\(A\\) 都与自身合同\n对称性：若 \\(A\\) 与 \\(B\\) 合同，则 \\(B\\) 与 \\(A\\) 合同\n传递性：若 \\(A\\) 与 \\(B\\) 合同，且 \\(B\\) 与 \\(C\\) 合同，则 \\(A\\) 与 \\(C\\) 合同\n\n对任一实对称矩阵 \\(A\\)，存在正交矩阵\n\\(P\\)，使 \\(P^{-1}AP = P^\\prime AP = D\\)\n为对角矩阵，因此，任一实对称矩阵都与对角矩阵合同。\n对称矩阵与非对称矩阵不合同。\n若 \\(A, B\\) 均为实对称矩阵，则 \\[\nA \\backsimeq B \\Leftrightarrow A与B的正惯性指数，负惯性指数对应相等\n\\]\n二次型\n定义\n含有 \\(n\\) 个变量 \\(x_1, x_2, \\cdots, x_n\\)，而系数取自数域\n\\(F\\) 的 \\(n\\) 元二次齐次函数 \\[\nf(x_1, x_2, \\cdots, x_n) = \\sum_{i = 1}^n\\sum_{j = 1}^n a_{ij}x_ix_j\n\\] 称为数域 \\(F\\) 上的\n\\(n\\)\n元二次型，简称二次型。\n记 \\[\nA = \\begin{pmatrix}\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\na_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\n\\vdots &amp; \\vdots &amp;   &amp; \\vdots \\\\\na_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\n\\end{pmatrix}\n,\\\nX = \\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{pmatrix}\n\\]\n则二次型可记为 \\[\nf = X^\\prime A X\n\\]\n称对称矩阵 \\(A\\) 为二次型\n\\(f\\) 的对称矩阵，称 \\(A\\) 的秩为二次型 \\(f\\) 的秩。\n化标准形\n称只含平方项的二次型为标准二次型。\n称形如 \\[\nf = y_1^2 + y_2^2 + \\cdots + y_p^2 - y_{p + 1}^2 - \\cdots - y_{p + 1}^2\n\\]\n的实二次型为规范二次型。 ### 正交变换 对任意 \\(n\\) 元实二次型 \\[\nf = X^\\prime AX\n\\]\n存在正交线性变换 \\[\nX = PY\n\\]\n将二次型 \\(f\\) 化为标准形 \\[\nf = \\lambda_1y_1^2 + \\lambda_2y_2^2 + \\cdots + \\lambda_ny_n^2\n\\]\n其中 \\(\\lambda_1, \\lambda_2, \\cdots,\n\\lambda_n\\) 是 \\(A\\) 的 \\(n\\) 个特征值。\n拉格朗日配方法\n初等变换（狗都不用）\n正定实二次型\n惯性定律\n设 \\(n\\) 元实二次型 \\(f = X^\\prime AX\\) 经实可逆线性变换 \\(X = C_1Y, X = C_2Z\\) 分别化为标准形 \\[\nf = k_1y_1^2 + k_2y_2^2 + \\cdots + k_ny_n^2\\\\\nf = l_1z_1^2 + l_2z_2^2 + \\cdots + l_nz_n^2\n\\]\n则 \\(k_1, k_2, \\cdots, k_n\\)\n中正数的个数与 \\(l_1, l_2, \\cdots,\nl_n\\) 中正数的个数相等，\\(k_1, k_2,\n\\cdots, k_n\\)中负数的个数与 \\(l_1, l_2,\n\\cdots, l_n\\) 中负数的个数也相等，分别称之为 \\(f\\)\n的正惯性指数与负惯性指数。\n正定二次型\n定义\n设有 \\(n\\) 元实二次型 \\(f = X^\\prime AX\\)，如果对 \\(\\mathbb{R}^n\\) 中任何列向量 \\(X \\ne 0\\)，都有 \\(X^\\prime AX &gt; 0\\)，则称 \\(f\\)\n为正定二次型。称正定二次型的矩阵为正定矩阵。\n显然，正定矩阵一定是实对称矩阵，反之未必。\n性质\n设 \\(A\\) 是 \\(n\\) 阶方阵，顺序选取 \\(A\\) 的前 \\(k(0\n\\le k \\le n)\\) 行、前 \\(k\\)\n列构成的矩阵称为 \\(A\\) 的 \\(k\\) 阶顺序主子阵，其行列式称为 \\(A\\) 的 \\(k\\) 阶顺序主子式。\n下面是 \\(n\\) 元实二次型 \\(f = X^\\prime AX\\) 为正定二次型的充要条件：\n1. \\(f\\) 的标准形中的 \\(n\\) 个系数全为正数，即 \\(f\\) 的正惯性指数是 \\(n\\)。 2. \\(f\\) 的矩阵 \\(A\\) 的特征值全大于零。 3. 存在实可逆矩阵\n\\(Q\\)，使 \\(A\n= Q^\\prime Q\\)。 4. \\(A\\)\n的各阶顺序主子式都大于零。\n空间中的曲面与直线\n球面\n已知球面的球心在点 \\(M_0(x_0, y_0,\nz_0)\\)，半径是 \\(r\\)，则该球面方程为 \\[\n(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = r^2\n\\]\n柱面\n平行于定直线并沿定曲线 \\(C\\)\n移动的直线 \\(L\\)\n形成的轨迹叫做柱面，定曲线 \\(C\\) 叫做柱面的准线，动直线\n\\(L\\) 叫做柱面的母线。\n### 椭圆柱面 \\[\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\n\\]\n双曲柱面\n\\[\n\\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1\n\\]\n抛物柱面\n\\[\nx^2 = 2py\n\\]\n旋转曲面\n由一条平面曲线 \\(C\\)\n绕该平面上的一条定直线 \\(L\\)\n旋转一周所成的曲面叫做旋转曲面，曲线 \\(C\\) 称为母线，直线 \\(L\\) 称为旋转轴。 ###\n圆锥面 \\[\nz^2 = k^2(x^2 + y^2)\n\\]\n单叶旋转双曲面\n\\[\n\\frac{x^2 + y^2}{a^2} - \\frac{z^2}{b^2} = 1\n\\]\n双叶旋转双曲面\n\\[\n\\frac{x^2}{a^2} - \\frac{y^2 + z^2}{b^2} = 1\n\\]\n旋转椭球面\n\\[\n\\frac{x^2 + y^2}{a^2} + \\frac{z^2}{b^2} = 1\n\\]\n旋转抛物面\n\\[\nx^2 + y^2 = 2pz\n\\]\n空间曲线\n空间曲线可以视为两个通过它的曲面的交线。若空间曲线 \\(C\\) 是两个曲面 \\[\nS_1 : F(x, y, z) = 0\\\\\nS_2 : G(x, y, z) = 0\n\\]\n的交线，则曲线 \\(C\\) 的方程为 \\[\n\\begin{cases}\nF(x, y, z) = 0\\\\\nG(x, y, z) = 0\n\\end{cases}\n\\]\n称其为空间曲线 \\(C\\)\n的一般方程。\n有时，空间曲线 \\(C\\)\n的方程也可以用参数表示成 \\[\n\\begin{cases}\nx = x(t)\\\\\ny = y(t)\\\\\nz = z(t)\n\\end{cases}\n\\]\n设 \\(C\\) 是一条空间曲线，\\(\\pi\\) 是一个平面，以 \\(C\\) 为准线，作母线垂直于 \\(\\pi\\) 的柱面，该柱面与平面 \\(\\pi\\) 的交线叫做 \\(C\\) 在平面 \\(\\pi\\)\n上的投影曲线，简称投影。\n设曲线 \\(C\\) 的方程是 \\[\n\\begin{cases}\nF_1(x, y, z) = 0\\\\\nF_2(x, y, z) = 0\n\\end{cases}\n\\]\n从这个方程组中消去 \\(z\\) 可以得到以\n\\(C\\) 为准线，母线垂直于 \\(xOy\\) 面的柱面方程 \\[\nF(x, y) = 0\n\\]\n故曲线 \\[\n\\begin{cases}\nF(x, y) = 0\\\\\nz = 0\n\\end{cases}\n\\]\n是曲线 \\(C\\) 在 \\(xOy\\) 面上的投影。\n二次曲线\n一般的三元二次方程都可写成 \\[\nX^\\prime AX + v^\\prime X + a_{44} = 0\n\\]\n存在正交变换 \\[\nX = PY\n\\]\n使二次型 \\(X^\\prime AX\\)\n化为标准二次型 \\(\\lambda_1x^{\\prime 2} +\n\\lambda_2y^{\\prime 2} + \\lambda_3z^{\\prime\n2}\\)。这意味着存在三维几何空间中适当的直角坐标系，使原来的三元二次方程化成\n\\[\n\\lambda_1x^{\\prime 2} + \\lambda_2y^{\\prime 2} + \\lambda_3z^{\\prime 2} +\na_{14}^\\prime x^\\prime + a_{24}^\\prime y^\\prime + a_{34}^\\prime z^\\prime\n+ a_{44} = 0\n\\]\n再作平移变换，可化简为 \\[\n\\lambda_1\\bar{x}^2 + \\lambda_2\\bar y^2 + \\lambda_3\\bar z^2 = d\n\\]\n椭球面\n\\[\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} + \\frac{z^2}{c^2} = 1\n\\]\n单叶双曲面\n\\[\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} - \\frac{z^2}{c^2} = 1\n\\]\n双叶双曲面\n\\[\n\\frac{x^2}{a^2} - \\frac{y^2}{b^2} - \\frac{z^2}{c^2} = 1\n\\]\n椭圆抛物面\n\\[\n\\frac{x^2}{2p} + \\frac{y^2}{2q} = z\\quad（p, q\\ 同号）\n\\]\n双曲抛物面（马鞍面）\n\\[\n\\frac{x^2}{2p} - \\frac{y^2}{2q} = z\\quad（p, q\\ 同号）\n\\]\n二次锥面\n\\[\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} - \\frac{z^2}{c^2} = 0\n\\]\n","tags":["Math","Linear Algebra"]},{"title":"黎曼积分","url":"/2024/02/28/Riemann-Integral/","content":"黎曼积分\n定义\n设 \\(\\Omega\\)\n为有限的几何体（一段曲线，一段曲面，一块有限空间体），\\(u = f(P)\\) 是定义在 \\(\\Omega\\) 上的点函数，将 \\(\\Omega\\) 任意分成 \\(n\\) 个小的几何体，\\(\\Delta\\Omega_1,\\Delta\\Omega_2,\\cdots,\\Delta\\Omega_n\\)，并用此记号表示其几何量，称\n\\(\\sup\\limits_{P_1, P_2 \\in\n\\Delta\\Omega_i}\\left\\{\\left\\vert P_1P_2 \\right\\vert\\right\\} =\nd_i\\) 为 \\(\\Delta\\Omega_i\\)\n的直径，\\(\\lambda =\n\\max\\limits_{i=1,2,\\cdots,n}\\{d_i\\}\\)，然后在每个小的几何形体\n\\(\\Delta\\Omega_i\\) 上做乘积 \\(f(P_i)\\Delta\\Omega_i, P_i \\in\n\\Delta\\Omega_i\\)，并将它们加起来，得 \\(\\sum_{i=1}^n\nf(P_i)\\Delta\\Omega_i\\)。如果不论 \\(\\Omega\\) 如何分，\\(P_i \\in \\Delta\\Omega_i\\) 如何取，下述极限\n\\(\\lim\\limits_{\\lambda \\to 0} \\sum_{i=1}^n\nf(P_i)\\Delta\\Omega_i\\) 均存在且相等，则称 \\(f(P)\\) 在 \\(\\Omega\\) 上可积，其极限值为 \\(f(P)\\) 在 \\(\\Omega\\) 上黎曼积分。一般记号，\\(\\lim\\limits_{\\lambda\\to 0} \\sum_{i=1}^n\nf(P_i)\\Delta\\Omega_i \\triangleq \\int\\limits_\\Omega\nf(P)d\\Omega\\)\n性质\n\n\\(\\int\\limits_\\Omega f(P)d\\Omega =\n\\int\\limits_\\Omega f(P)dV\\)，积分与变量无关\n\\(\\int\\limits_\\Omega d\\Omega =\n\\Omega\\)\n\\(\\int\\limits_\\Omega \\left[\\alpha f(P) \\pm\n\\beta g(P)\\right]d\\Omega = \\alpha \\int\\limits_\\Omega f(P)d\\Omega \\pm\n\\beta\\int\\limits_\\Omega g(P)d\\Omega\\)\n若 \\(\\Omega = \\Omega_1 +\n\\Omega_2\\)，则 \\(\\int\\limits_\\Omega\nf(P) d\\Omega = \\int\\limits_{\\Omega_1} f(P) d\\Omega +\n\\int\\limits_{\\Omega_2} f(P)d\\Omega\\)\n若 \\(f(P) \\ge g(P), P \\in\n\\Omega\\)，则 \\(\\int\\limits_\\Omega f(P)\nd\\Omega \\ge \\int\\limits_\\Omega g(P)d\\Omega\\)\n若 \\(P \\in \\Omega\\)，则 \\(\\left\\vert \\int\\limits_\\Omega f(P)d\\Omega\n\\right\\vert \\le \\int\\limits_\\Omega \\left\\vert f(P) \\right\\vert\nd\\Omega\\)\n若 \\(m \\le f(P) \\le M, P \\in\n\\Omega\\)，则 \\(m\\Omega \\le\n\\int\\limits_\\Omega f(P)d\\Omega \\le M\\Omega\\)\n设 \\(f(P)\\) 是有界闭区域 \\(\\Omega\\) 上连续函数，则 \\(\\int\\limits_\\Omega f(P)d\\Omega = f(P^*)\\Omega, P^*\n\\in \\Omega\\)\n若 \\(\\Omega\\) 关于 \\(x=0(y=0,z=0)\\) 对称，且 \\(f(P)\\) 是关于 \\(x(y,z)\\) 的奇函数，则 \\(\\int\\limits_\\Omega f(P)d\\Omega = 0\\)\n\n一般意义\n表示以 \\(f(P)\\) 为密度函数的几何体\n\\(\\Omega\\) 的质量代数和。\n二重积分\n定义\n若 \\(D\\) 是坐标面（不妨设为）\\(oxy\\) 平面上的一个有界闭区域，在坐标系下\n\\(f(P)\\) 就是一个二元函数 \\(f(x,y)\\)，称它在 \\(D\\) 上的黎曼积分为 \\(f(x,y)\\) 在 \\(D\\) 上的二重积分，记为\n\\[\n\\iint\\limits_D f(x,y)d\\sigma = \\iint\\limits_D f(x,y)dxdy\n\\]\n物理意义\n表示以 \\(f(x,y)\\)\n为面密度的有限平面区域质量的代数和。\n几何意义\n表示以 \\(D\\) 为底，以 \\(z=f(x,y)\\) 为顶的曲顶柱体体积的代数和。\n计算公式\n\n\\(Y-\\) 型：\\(\\begin{cases}  a \\le y \\le b \\\\  \\varphi(y) \\le x\n\\le \\psi(y) \\end{cases}\\) \\[\n\\iint\\limits_D f(x,y)dxdy = \\int_a^b dy\n\\int_{\\varphi(y)}^{\\psi(y)}f(x,y)dx\n\\]\n\\(X-\\) 型：\\(\\begin{cases}  a \\le x \\le b \\\\  \\varphi(x) \\le y\n\\le \\psi(x) \\end{cases}\\) \\[\n\\iint\\limits_D f(x,y)dxdy = \\int_a^b dx\n\\int_{\\varphi(x)}^{\\psi(x)}f(x,y)dy\n\\]\n极坐标系：\\(\\begin{cases}  \\alpha \\le\n\\theta \\le \\beta \\\\  \\varphi(\\theta) \\le r \\le \\psi(\\theta)\n\\end{cases}\\) \\[\n\\iint\\limits_D f(x,y)dxdy = \\int_\\alpha^\\beta d\\theta\n\\int_{\\varphi(\\theta)}^{\\psi(\\theta)}f(r\\cos\\theta, r\\sin\\theta)rdr\n\\]\n\n积分换序\n如果 \\(X-\\) 型走不通，不妨用 \\(Y-\\) 型试试。\n三重积分\n定义\n若 \\(\\Omega\\) 是一有限空间体，\\(f(P)\\) 是 \\(\\Omega\\) 上的点函数，在坐标系下 \\(f(P)\\) 就是一个三元函数 \\(f(x,y,z)\\)，它在 \\(\\Omega\\) 上的黎曼积分称之为 \\(f(x,y,z)\\) 在 \\(\\Omega\\)\n上的三重积分，记为 \\[\n\\iiint\\limits_\\Omega f(x,y,z)d\\Omega = \\iiint\\limits_\\Omega\nf(x,y,z)dxdydz\n\\]\n物理意义\n表示以 \\(f(x,y,z)\\)\n为体密度的有限空间体 \\(\\Omega\\)\n质量的代数和。\n计算方法\n\n柱形域：\\(\\begin{cases}  \\varphi(x,y)\n\\le z \\le \\psi(x,y) \\\\  (x,y) \\in D_{xy} \\end{cases}\\) \\[\n\\iiint\\limits_\\Omega f(x,y,z) dxdydz = \\iint\\limits_{D_{xy}}dxdy\n\\int_{\\phi(x,y)}^{\\psi(x,y)}f(x,y,z)dz\n\\]\n片型域：\\(\\begin{cases}  a \\le z \\le b\n\\\\  (x,y) \\in D_z \\end{cases}\\) \\[\n\\iiint_\\Omega f(x,y,z)dxdydz = \\int_a^b dz\\iint\\limits_{D_z}f(x,y,z)dxdy\n\\]\n球坐标系：\\(\\begin{cases}  a \\le \\theta\n\\le b \\\\  c \\le \\phi \\le d \\\\  g(\\theta, \\phi) \\le \\rho \\le h(\\theta,\n\\phi) \\end{cases}\\) \\[\n\\iiint\\limits_\\Omega f(x,y,z)dxdydz = \\int_a^b d\\theta \\int_c^d d\\phi\n\\int_{g(\\theta, \\phi)}^{h(\\theta, \\phi)} f(\\rho\\sin\\phi\\cos\\theta,\n\\rho\\sin\\phi\\sin\\theta, \\rho\\cos\\phi)\\rho^2\\sin\\phi d\\rho\n\\]\n\n第一型曲线积分\n定义\n若 \\(C\\)\n是空间（或平面）一有限曲线段，\\(f(P)\\)\n是 \\(C\\)\n上点函数，在引进坐标系下，\\(f(P) =\nf(x,y,z)(f(x,y))\\)，称 \\(f(P)\\)\n在 \\(C\\) 上黎曼积分叫 \\(f\\) 在 \\(C\\)\n上的第一型曲线积分，记为 \\[\n\\int\\limits_C f(x,y,z) ds \\left(或\\int\\limits_C f(x,y)ds\\right)\n\\]\n物理意义\n表示以 \\(f(x,y,z)\\) 或 \\(f(x,y)\\) 为线密度的曲线 \\(C\\) 的质量的代数和。\n几何意义\n表示以 \\(C\\) 为准线，母线平行于\n\\(oz\\) 轴的柱面介于 \\(oxy\\) 平面与 \\(z=f(x,y)\\) 之间面积的代数和。\n计算方法\n将曲线 \\(C\\)\n用参数方程来表示，然后代入积分公式转化成一元积分。\n第一型曲面积分\n定义\n若 \\(S\\) 是空间上一有限曲面，\\(f(P)\\) 是 \\(S\\) 上的点函数，在引进坐标系下，\\(f(P) = f(x,y,z)\\)，\\(f(P)\\) 在 \\(S\\) 上黎曼积分叫 \\(f(P)\\) 在 \\(S\\)\n上的第一型曲面积分，记为 \\[\n\\iint\\limits_S f(x,y,z) dS\n\\]\n物理意义\n表示以 \\(f(x,y,z)\\) 为面密度的曲面\n\\(S\\) 的质量的代数和。\n计算方法\n转化为二重积分 \\[\n\\iint\\limits_S f(x,y,z)dS = \\iint\\limits_D f(x,y,g(x,y))\n\\sqrt{g_x^{\\prime\\ 2} + g_y^{\\prime\\ 2} + 1} dxdy\n\\]\n","tags":["Math","Calculus"]},{"title":"在服务器上生成SSL证书并部署至Nginx","url":"/2024/04/02/SSL/","content":"获取环境与项目\napt install socat -ygit clone https://github.com/acmesh-official/acme.sh.git\n生成证书并导入到Nginx\ncd .acme.sh./acme.sh --install -m intro-iu@outlook.comexport CF_Key=&quot;&quot; &amp;&amp; export CF_Email=&quot;&quot;./acme.sh --issue --dns dns_cf -d intro-iu.top -d *.intro-iu.topmkdir /etc/nginx/ssl./acme.sh --installcert -d intro-iu.top --keypath /etc/nginx/ssl/intro-iu.top.key --fullchainpath /etc/nginx/ssl/intro-iu.top.cer\n更改Nginx配置使证书生效\nvim /etc/nginx/nginx.conf\n在SSL区块中添加一下两行\nssl_certificate ssl/intro-iu.top.cer;ssl_certificate_key ssl/intro-iu.top.key;\n重启Nginx\nnginx -tsystemctl reload nginx\n"},{"title":"级数","url":"/2024/02/29/Series/","content":"级数\n定义\n设 \\(\\{a_n\\}\\) 为一个无穷数列，用\n+ 将 \\(a_n\\)\n的项依次连起来，得到一个式子 \\(a_1 + a_2 +\n\\cdots + a_n + \\cdots\\)，称此式子为\n（无穷数项）级数，简记为 \\(\\sum\\limits_{n=1}^\\infty a_n\\)\n\\(a_1\\) 称为第一项，\\(a_n\\) 称为通项，\\(S_n = a_1 + a_2 + \\cdots + a_n\\)\n称为部分和。\n敛散性\n设 \\(\\sum\\limits_{n=1}^\\infty a_n\\)\n为一级数，\\(S_n = a_1 + a_2 + \\cdots +\na_n\\) 为其部分和，若 \\(\\lim\\limits_{n\\to\\infty} S_n\\)\n存在，则称级数 \\(\\sum\\limits_{n=1}^\\infty\na_n\\) 收敛，此时 \\(\\lim\\limits_{n\\to\\infty} S_n =\n\\sum\\limits_{n=1}^\\infty a_n\\)。若 \\(\\lim\\limits_{n\\to\\infty} S_n\\)\n不存在，则称级数 \\(\\sum\\limits_{n=1}^\\infty\na_n\\) 发散。\n性质\n\n\\(k \\ne 0\\) 时，\\(\\sum\\limits_{n=1}^\\infty a_n\\) 与 \\(\\sum\\limits_{n=1}^\\infty ka_n\\)\n的敛散性一致，且收敛时 \\(\\sum\\limits_{n=1}^\\infty ka_n =\nk\\sum\\limits_{n=1}^\\infty a_n\\)。\n若 \\(\\sum\\limits_{n=1}^\\infty a_n\\)\n与 \\(\\sum\\limits_{n=1}^\\infty b_n\\)\n都收敛，则 \\(\\sum\\limits_{n=1}^\\infty (a_n \\pm\nb_n)\\) 也收敛，且 \\(\\sum\\limits_{n=1}^\\infty (a_n \\pm b_n) =\n\\sum\\limits_{n=1}^\\infty a_n \\pm \\sum\\limits_{n=1}^\\infty\nb_n\\)。\n一个级数去掉或添加有限项不改变级数的敛散性。\n收敛级数满足结合律。\n若 \\(\\sum\\limits_{n=1}^\\infty a_n\\)\n收敛，则 \\(\\lim\\limits_{n\\to\\infty} a_n =\n0\\)。\n\n两个重要级数\n等比级数\n\\[\\sum\\limits_{n=1}^\\infty\nr^n\\]\n当 \\(\\vert r\\vert &lt; 1\\)\n时收敛；\n当 \\(\\vert r \\vert \\ge 1\\)\n时发散。\np-级数\n\\[\\sum\\limits_{n=1}^\\infty\n\\frac{1}{n^p}\\]\n当 \\(0 &lt; p \\le 1\\) 时发散；\n当 \\(p&gt;1\\) 时收敛。\n正项级数\n定义\n称满足 \\(a_n &gt; 0\\) 的无穷级数\n\\(\\sum\\limits_{n=1}^\\infty a_n\\)\n为正项级数。\n敛散性判别法\n\n正项级数 \\(\\sum\\limits_{n=1}^\\infty\\) 收敛 \\(\\Leftrightarrow\\) 部分和有上界。\n比较判别法\n\n设 \\(\\sum\\limits_{n=1}^\\infty\na_n\\)，\\(\\sum\\limits_{n=1}^\\infty\nb_n\\) 为两个正项级数，若从某项以后有 \\(a_n \\le b_n\\)，则\n当 \\(\\sum\\limits_{n=1}^\\infty b_n\\)\n收敛时，\\(\\sum\\limits_{n=1}^\\infty\na_n\\) 收敛；\n当 \\(\\sum\\limits_{n=1}^\\infty a_n\\)\n发散时，\\(\\sum\\limits_{n=1}^\\infty\nb_n\\) 发散。\n交错级数\n定义\n设 \\(a_n &gt; 0\\)，称 \\(\\sum\\limits_{n=1}^\\infty (-1)^n a_n\\) 或\n\\(\\sum\\limits_{n=1}^\\infty (-1)^{n+1}\na_n\\) 为交错级数。\n性质\n设交错级数 \\(\\sum\\limits_{n=1}^\\infty\n(-1)^n a_n\\) 满足 \\(\\lim\\limits_{n\\to\\infty} a_n = 0\\)，且\n\\(a_n \\ge a_{n+1}\\)，\\(n = 1, 2, \\cdots\\)，则交错级数 \\(\\sum\\limits_{n=1}^\\infty (-1)^n a_n\\)\n收敛。\n绝对收敛级数\n定义\n若 \\(\\sum\\limits_{n=1}^\\infty \\vert u_n\n\\vert\\) 收敛，则称级数 \\(\\sum\\limits_{n=1}^\\infty u_n\\)\n为绝对收敛。\n性质\n\n绝对收敛级数必收敛\n绝对收敛级数满足交换律\n\n条件收敛级数\n定义\n若 \\(\\sum\\limits_{n=1}^\\infty \\vert u_n\n\\vert\\) 发散，而 \\(\\sum\\limits_{n=1}^\\infty u_n\\)\n收敛，则称级数 \\(\\sum\\limits_{n=1}^\\infty\nu_n\\) 条件收敛。\n性质\n条件收敛级数不满足交换律。\n","tags":["Math","Series"]},{"title":"空间几何","url":"/2024/03/12/Space-Geometry/","content":"向量\n数量积\n定义\n设 \\(a, b\\) 是两个几何向量，称 \\(\\left\\vert a\\right\\vert \\left\\vert b\\right\\vert\n\\cos\\theta\\) 为 \\(a\\) 与 \\(b\\)\n的数量积或内积，记作 \\(a \\cdot b\\)，即 \\[a \\cdot b = \\left\\vert a\\right\\vert \\left\\vert\nb\\right\\vert \\cos\\theta\\]\n性质\n\n\\(a \\cdot b = b \\cdot\na\\)（交换律）\n\\((ka) \\cdot b = k(a \\cdot\nb)\\)\n\\((a + b) \\cdot c = a \\cdot c + b \\cdot\nc\\)（分配律）\n\\(a \\cdot a \\ge 0\\)。此外，\\(a \\cdot a = 0\\) 的充要条件是 \\(a = 0\\)。\n\n向量积\n定义\n若 \\(a, b\\) 不平行，则 - \\(\\left\\vert a \\times b\\right\\vert = \\left\\vert\na\\right\\vert \\left\\vert b\\right\\vert \\sin\\theta\\) - \\(a \\times b \\perp a, a \\times b \\perp b\\) -\n向量 \\(a, b, a \\times b\\)\n构成右手系\n性质\n\n\\(a \\times b = -b \\times a\\)\n\\((ka)\\times b = k(a\\times b) = a \\times\n(kb)\\)\n\\((a + b) \\times c = (a \\times c) + (b\n\\times c)\\\\a \\times (b + c) = (a \\times b) + (a \\times c)\\)\n\n混合积\n定义\n已知三个向量 \\(a, b\\) 和 \\(c\\)。先作 \\(a\\) 和 \\(b\\) 的向量积 \\(a\n\\times b\\)，把所得的向量与 \\(c\\)\n再作数量积 \\((a \\times b) \\cdot\nc\\)，这样得到的数量叫做三向量 \\(a, b,\nc\\) 的混合积，记为 \\(\\left[abc\\right]\\)。\n向量的混合积有如下几何意义：\\(\\left[abc\\right] = (a \\times b) \\cdot c\\)\n的绝对值表示以向量 \\(a, b, c\\)\n为棱的平行六面体的体积。如果向量 \\(a, b,\nc\\) 组成右手系，那么混合积的符号是正的；如果 \\(a, b, c\\)\n组成左手系，那么混合积的符号是负的。\n性质\n\\[ \\left[abc\\right] = 0 \\Leftrightarrow\na,b,c\\ 共面\\] \\[\\left[abc\\right] =\n\\left[bca\\right] = \\left[cab\\right] = -\\left[bac\\right] =\n-\\left[cba\\right] = -\\left[acb\\right]\\] 设 \\(a = (a_x, a_y, a_z), b = (b_x, b_y, b_z), c =\n(c_x, c_y, c_z)\\)，则 \\[\n[abc] =\n\\begin{vmatrix}\na_x &amp; a_y &amp; a_z \\\\\nb_x &amp; b_y &amp; b_z \\\\\nc_x &amp; c_y &amp; c_z\n\\end{vmatrix}\n\\] # 空间中的平面与直线\n平面\n设平面 \\(\\pi\\) 通过点 \\(M_0(x_0, y_0, z_0)\\) 并且垂直于非零向量\n\\(n = (A, B, C)\\)，则平面 \\(\\pi\\) 的点法式方程为：\n\\[A(x - x_0) + B(y - y_0) + C(z - z_0) =\n0\\] 将其整理得 \\[Ax + By + Cz + D =\n0\\] 其中 \\(D = -(Ax_0 + By_0 +\nCz_0)\\)，称其为平面 \\(\\pi\\)\n的一般方程\n设 \\(M_1(x_1, y_1, z_1), M_2(x_2, y_2,\nz_2), M_3(x_3, y_3, z_3)\\) 是空间中不在同一条直线上的三点，则称\n\\[\\begin{vmatrix}\nx - x_1 &amp; y - y_1 &amp; z - z_1\\\\\nx_2 - x_1 &amp; y_2 - y_1 &amp; z_2 - z_1\\\\\nx_3 - x_1 &amp; y_3 - y_1 &amp; z_3 - z_1\n\\end{vmatrix}\n= 0\\] 为平面 \\(\\pi\\)\n的三点式方程。\n设平面 \\(\\pi\\) 与 \\(x, y, z\\) 轴分别交于 \\(P(a, 0, 0), Q(0, b, 0), R(0, 0, c)\\)，则称\n\\[\\frac{x}{a} + \\frac{y}{b} + \\frac{z}{c} =\n1\\] 为平面 \\(\\pi\\)\n的截距式方程。\n直线\n设直线 \\(L\\) 过点 \\(M_0(x_0, y_0,\nz_0)\\)，并且平行于已知非零向量 \\(s =\n(m, n, p)\\)，则称 \\[\\frac{x - x_0}{m}\n= \\frac{y - y_0}{n} = \\frac{z - z_0}{p}\\] 为直线 \\(L\\) 的标准方程。\n令其比值为 \\(t\\)，则称 \\[\\begin{cases}\nx = x_0 + mt \\\\\ny = y_0 + nt \\\\\nz = z_0 + pt\n\\end{cases}\\] 为直线 \\(L\\)\n的参数方程。\n设平面 \\(\\pi_1, \\pi_2\\) 为 \\[\\pi_1 : A_1x + B_1y + C_1z + D_1 = 0\\\\\n\\pi_2 : A_2x + B_2y + C_2z + D_2 = 0\\] 若 \\(\\pi_1, \\pi_2\\) 的交线为直线 \\(L\\)，则称 \\[\\begin{cases}\nA_1x + B_1y + C_1z + D_1 = 0\\\\\nA_2x + B_2y + C_2z + D_2 = 0\n\\end{cases}\\] 为直线 \\(L\\)\n的一般方程。\n设直线 \\(L\\) 过点 \\(M_0(x_0, y_0, z_0)\\) 和点 \\(M_1(x_1, y_1, z_1)\\)，则称 \\[\\frac{x - x_0}{x_1 - x_0} = \\frac{y - y_0}{y_1 -\ny_0} = \\frac{z - z_0}{z_1 - z_0}\\] 为直线 \\(L\\) 的二点式方程。\n位置关系\n平面与平面\n设有两个平面 \\[\n\\pi_1 : A_1x + B_1y + C_1z + D_1 = 0 \\\\\n\\pi_2 : A_2x + B_2y + C_2z + D_2 = 0\n\\] 可将 \\(\\pi_1, \\pi_2\\)\n的位置关系分为如下三种情形。\n\n\\(\\pi_1, \\pi_2\\) 重合。其充要条件是\n\\[\n\\frac{A_1}{A_2} = \\frac{B_1}{B_2} = \\frac{C_1}{C_2} = \\frac{D_1}{D_2}\n\\]\n\\(\\pi_1, \\pi_2\\)\n平行（不包括重合）。其充要条件是 \\[\n\\frac{A_1}{A_2} = \\frac{B_1}{B_2} = \\frac{C_1}{C_2} \\ne \\frac{D_1}{D_2}\n\\]\n\\(\\pi_1, \\pi_2\\)\n交于一条直线。其充要条件是 \\(n_1 = (A_1, B_1,\nC_1)\\) 与 \\(n_2 = (A_2, B_2,\nC_2)\\) 不平行。\n\n当 \\(\\pi_1, \\pi_2\\)\n是两个相交的平面时，称它们的法向量的夹角 \\(\\varphi\\) 为这两个平面的夹角，通常规定\n\\[0 \\le \\varphi \\le \\frac{\\pi}{2}\\]\n平面 \\(\\pi_1\\) 与 \\(\\pi_2\\) 的夹角 \\(\\varphi\\) 可由公式 \\[\n\\cos\\varphi = \\frac{\\left\\vert A_1A_2 + B_1B_2 + C_1C_2\n\\right\\vert}{\\sqrt{A_1^2 + B_1^2 + C_1^2}\\sqrt{A_2^2 + B_2^2 + C_2^2}}\n\\] 来确定。\n显然，\\(\\pi_1\\) 与 \\(\\pi_2\\) 垂直的充要条件时它们的法向量 \\(n_1\\) 与 \\(n_2\\) 垂直，即 \\[A_1A_2 + B_1B_2 + C_1C_2 = 0\\]\n直线与直线\n设有两条直线 \\[\nL_1 : \\frac{x - x_1}{m_1} = \\frac{y - y_1}{n_1} = \\frac{z - z_1}{p_1}\\\\\nL_2 : \\frac{x - x_2}{m_2} = \\frac{y - y_2}{n_2} = \\frac{z - z_2}{p_2}\n\\] \\(M_1(x_1, y_1, z_1), M_2(x_2, y_2,\nz_2)\\) 分别是 \\(L_1, L_2\\)\n上的定点。\\(s_1=(m_1, n_1, p_1), s_2=(m_2,\nn_2, p_2)\\) 分别是 \\(L_1, L_2\\)\n的方向向量。\n可将 \\(L_1, L_2\\)\n的位置关系分成如下四种情形 1. \\(L_1,\nL_2\\) 重合。其充要条件是 \\[\n\\frac{m_1}{m_2} = \\frac{n_1}{n_2} = \\frac{p_1}{p_2}\n\\] 且 \\(M_1 \\in L_2 \\ (M_2 \\in\nL_1)\\)，即 \\[\n\\frac{x_1 - x_2}{m_2} = \\frac{y_1 - y_2}{n_2} = \\frac{z_1 - z_2}{p_2}\n\\] 2. \\(L_1, L_2\\)\n平行（不包括重合）。其充要条件是 \\[\n\\frac{m_1}{m_2} = \\frac{n_1}{n_2} = \\frac{p_1}{p_2}\n\\] 且 \\(M_1 \\notin L_2 \\ (M_2 \\notin\nL_1)\\)，即 \\[\n\\frac{x_1 - x_2}{m_2} = \\frac{y_1 - y_2}{n_2} = \\frac{z_1 - z_2}{p_2}\n\\] 不成立。\n\n\\(L_1, L_2\\)\n交于一点。其充要条件是混合积 \\(\\left[s_1s_2\\overrightarrow{M_1M_2}\\right] =\n0\\) 且 \\(s_1s_2\\)\n不平行。\n\\(L_1, L_2\\)\n是异面直线。其充要条件是混合积 \\(\\left[s_1s_2\\overrightarrow{M_1M_2}\\right] \\ne\n0\\)。\n\n我们规定 \\(L_1, L_2\\) 的方向向量\n\\(s_1, s_2\\) 的夹角 \\(\\varphi\\) 为这两条直线的夹角。通常规定\n\\(0 \\le \\varphi \\le\n\\frac{\\pi}{2}\\)。\n直线 \\(L_1, L_2\\) 的夹角 \\(\\varphi\\) 可由公式 \\[\n\\cos\\varphi = \\frac{\\left\\vert s_1 \\cdot s_2\\right\\vert}{\\left\\vert\ns_1\\right\\vert \\left\\vert s_2 \\right\\vert}\n\\] 来确定。\n显然，\\(L_1\\) 与 \\(L_2\\) 垂直的充要条件是 \\(s_1\\) 与 \\(s_2\\) 垂直，即 \\[\ns_1 \\cdot s_2 = m_1m_2 + n_1n_2 + p_1p_2 = 0\n\\]\n直线与平面\n设有一条直线 \\[\nL : \\frac{x - x_0}{m} = \\frac{y - y_0}{n} = \\frac{z - z_0}{p}\n\\] 及一个平面 \\[\n\\pi : Ax + By + Cz + D = 0\n\\] 可将 \\(L, \\pi\\)\n的位置关系分成如下三种情形。 1. \\(L\\)\n在 \\(\\pi\\) 上。其充要条件是 \\(s = (m, n, p)\\) 与 \\(n = (A, B, C)\\) 垂直，且 \\(M_0 \\in \\pi\\)，即 \\[\n\\begin{cases}\nmA + nB + pC = 0\\\\\nAx_0 + By_0 + Cz_0 + D = 0\n\\end{cases}\n\\] 2. \\(L\\) 与 \\(\\pi\\) 平行（不包括 \\(L\\) 在 \\(\\pi\\) 上的情形）。其充要条件是 \\(s = (m, n, p)\\) 与 \\(n = (A, B, C)\\) 垂直，且 \\(M_0 \\notin \\pi\\)，即 \\[mA + nB + pC = 0\\] 且 \\[Ax_0 + By_0 + Cz_0 + D \\ne 0\\] 3. \\(L\\) 与 \\(\\pi\\) 交于一点。其充要条件是 \\(s = (m, n, p)\\) 与 \\(n = (A, B, C)\\) 不垂直，即 \\[mA + nB + pC \\ne 0\\] 直线 \\(L\\) 与其在平面 \\(\\pi\\) 上的投影直线 \\(L_1\\) 的夹角 \\(\\varphi\\) 称为直线 \\(L\\) 与平面 \\(\\pi\\) 的夹角，通常规定 \\(0 \\le \\varphi \\le \\frac{\\pi}{2}\\)。\n\\(\\varphi\\) 可由公式 \\[\n\\sin\\varphi = \\frac{\\left\\vert s \\cdot n \\right\\vert}{\\left\\vert s\n\\right\\vert \\left\\vert n \\right\\vert}\n\\] 确定。显然，\\(L\\) 与 \\(\\pi\\) 垂直的充要条件是 \\(n\\) 与 \\(s\\) 平行，即 \\[\n\\frac{A}{m} = \\frac{B}{n} = \\frac{C}{p}\n\\]\n距离\n点到平面\n设 \\(M_0(x_0, y_0, z_0)\\) 是平面\n\\(\\pi : Ax + By + Cz + D = 0\\)\n外一点。在平面 \\(\\pi\\) 上任取一点 \\(M_1(x_1, y_1, z_1)\\)，取平面 \\(\\pi\\) 的法向量 \\(n = (A, B, C)\\)，则点 \\(M_0\\) 到平面 \\(\\pi\\) 的距离 \\(d\\) 为 \\[d =\n\\frac{\\left\\vert n \\cdot \\overrightarrow{M_0M_1} \\right\\vert}{\\left\\vert\nn \\right\\vert} \\]\n两平行平面\n可以转化为点到平面间的距离\n直线到其平行的平面\n可以转化为点到平面间的距离\n点到直线\n设直线 \\(L\\) 的标准方程为 \\[\nL : \\frac{x - x_0}{m} = \\frac{y - y_0}{n} = \\frac{z - z_0}{p}\n\\] 即 \\(L\\) 过点 \\(M_0(x_0, y_0, z_0)\\)，并且方向向量为 \\(s = (m, n, p)\\)。再设 \\(M_1(x_1, y_1, z_1)\\) 是直线 \\(L\\) 外一点，则点 \\(M_1\\) 到直线 \\(L\\) 的距离 \\(d\\) 为 \\[\nd = \\frac{\\left\\vert s \\times\n\\overrightarrow{M_0M_1}\\right\\vert}{\\left\\vert s\\right\\vert}\n\\]\n两平行直线\n可以转化为点到直线间的距离\n两异面直线\n设由两条异面直线： \\[\nL_1 : \\frac{x - x_1}{m_1} = \\frac{y - y_1}{n_1} = \\frac{z - z_1}{p_1}\\\\\nL_2 : \\frac{x - x_2}{m_2} = \\frac{y - y_2}{n_2} = \\frac{z - z_2}{p_2}\n\\] 记 \\(P_1(x_1, y_1, z_1), P_2(x_2,\ny_2, z_2)\\) 分别是 \\(L_1, L_2\\)\n上的点。\\(L_1, L_2\\) 的方向向量 \\(s_1 = (m_1, n_1, p_1)\\)，\\(s_2 = (m_2, n_2, p_2)\\) 分别与 \\(L_1, L_2\\) 的公垂线垂直，所以 \\(s_1 \\times s_2\\) 是 \\(L_1, L_2\\) 的公垂线的方向向量。\n\\(\\overrightarrow{P_1P_2}\\) 在 \\(s_1 \\times s_2\\) 上的投影的绝对值就是 \\(L_1\\) 与 \\(L_2\\) 之间的距离 \\(d\\)，即 \\[\nd = \\left\\vert \\overrightarrow{P_1P_2} \\cdot \\frac{s_1 \\times\ns_2}{\\left\\vert s_1 \\times s_2 \\right\\vert} \\right\\vert\n\\]\n平面束\n称通过给定直线 \\(L\\)\n的所有平面的全体为通过直线 \\(L\\)\n的平面束。\n设 \\(L\\) 的一般方程为 \\[\n\\begin{cases}\nA_1x + B_1y + C_1z + D_1 = 0\\\\\nA_2x + B_2y + C_2z + D_2 = 0\n\\end{cases}\n\\] 其中系数 \\(A_1, B_1, C_1\\) 与\n\\(A_2, B_2, C_2\\) 不成比例。则称方程\n\\[\nA_1x + B_1y + C_1z + D_1 + \\lambda(A_2x + B_2y + C_2z + D_2) = 0\n\\] 为通过直线 \\(L\\)\n的平面束方程。\n","tags":["Math"]},{"title":"三角级数","url":"/2024/03/02/Trigonometric-Series/","content":"三角级数\n定义\n称 \\(\\frac{1}{2}a_0 +\n\\sum\\limits_{n=1}^\\infty a_n\\cos nx + b_n \\sin nx\\)\n为三角级数。\n傅里叶级数\n定义\n若 \\(f(x)\\) 以 \\(2\\pi\\) 为周期，且以下积分存在 \\[\n\\begin{split}\n    &amp;a_0 = \\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)dx \\\\\n    &amp;a_n = \\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\cos nxdx \\\\\n    &amp;b_n = \\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)\\sin nxdx\n\\end{split}\n\\] 称 \\(\\frac{1}{2} a_0 +\n\\sum\\limits_{n=1}^\\infty a_n \\cos nx + b_n \\sin nx\\) 为 \\(f(x)\\)\n的傅里叶级数，简称为 \\(F-\\) 级数。\n其中 \\(a_0, a_n, b_n(n=1,2,\\cdots)\\)\n为傅里叶系数。\n若 \\(f(x)\\) 为奇函数，\\(a_0 = a_n = 0(n=1, 2, \\cdots)\\)，\\(b_n = \\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin nx\ndx\\)，此时 \\(F-\\) 级数变为 \\(\\sum\\limits_{n=1}^\\infty b_n \\sin\nnx\\)，称为 \\(F-\\)\n正弦型级数。\n若 \\(f(x)\\) 为偶函数，\\(b_n = 0, a_0 = \\frac{2}{\\pi}\\int_0^\\pi f(x)dx, a_n\n= \\frac{2}{\\pi}\\int_0^\\pi f(x)\\cos nx dx, (n=1,2,\\cdots)\\)，此时\n\\(F-\\) 级数变为 \\(\\frac{1}{2} a_0 + \\sum\\limits_{n=1}^\\infty a_n\n\\cos nx\\)，称为 \\(F-\\)\n余弦型级数\n狄利克雷定理\n若 \\(f(x)\\) 在 \\([-\\pi, \\pi]\\) 上满足： 1.\n至多有限个第一类间断点 2. 至多有限个极值\n则 \\(f(x)\\) 在 \\([-\\pi, \\pi]\\) 上 \\(F-\\) 级数收敛，且 \\[\n\\frac{1}{2}a_0 + \\sum\\limits_{n=1}^\\infty (a_n \\cos nx + b_n \\sin nx) =\n\\begin{cases}\n    f(x) &amp; x 为 (-\\pi, \\pi) 的连续点 \\\\\n    \\frac{1}{2}  \\left[f(x^+) + f(x^-)\\right] &amp; x 为 (-\\pi, \\pi)\n的第一类间断点 \\\\\n    \\frac{1}{2} \\left[f(-\\pi^+) + f(\\pi^-)\\right]&amp; x = \\pm\\pi\n\\end{cases}\n\\]\n以 \\(2l\\) 为周期的函数的傅里叶级数\n\\(f(x)\\) 在 \\([-l, l]\\) 的 \\(F-\\) 级数为 \\(\\frac{1}{2}a_0 + \\sum\\limits_{n=1}^\\infty\n\\left(a_n \\cos \\frac{n\\pi}{l}x + b_n \\sin\n\\frac{n\\pi}{l}x\\right)\\)，其中 \\[\n\\begin{split}\n    &amp;a_0 = \\frac{1}{l}\\int_{-l}^l f(x)dx \\\\\n    &amp;a_n = \\frac{1}{l}\\int_{-l}^l f(x)\\cos \\frac{n\\pi}{l}xdx \\\\\n    &amp;b_n = \\frac{1}{l}\\int_{-l}^l f(x)\\sin \\frac{n\\pi}{l}xdx\n\\end{split}\n\\]\n有限区间上函数的傅里叶级数\n对在 \\([a,b]\\) 定义的函数 \\(f(x)\\) 的傅里叶级数，可以将 \\(f(x)\\) 延拓成以 \\(T = b-a\\) 为周期的函数\n在 \\([0,l]\\) 上的正弦型级数\n方法： 将 \\(f(x)\\)\n奇延拓成 \\([-l, l]\\) 上的奇函数 \\[\ng(x) = \\begin{cases}\n    f(x) &amp; x \\in [0, l] \\\\\n    -f(x) &amp; x \\in [-l, 0)\n\\end{cases}\n\\] 则 \\(g(x)\\) 在 \\([-l, l]\\) 上的 \\(F-\\) 级数就是 \\(f(x)\\) 在 \\([0,\nl]\\) 上正弦型级数。 \\[\nb_n = \\frac{2}{l} \\int_0^l f(x) \\sin \\frac{n\\pi}{l}xdx\n\\] \\[\n\\sum\\limits_{n=1}^\\infty b_n \\sin \\frac{n\\pi}{l}x = \\begin{cases}\n\\begin{gather*}\n    \\frac{1}{2}\\left[f(x^+) + f(x^-)\\right] &amp;x\\in (0, l) \\\\\n    0 &amp; x=0,l\n\\end{gather*}\n\\end{cases}\n\\]\n","tags":["Math","Series"]},{"title":"第二型积分","url":"/2024/03/02/Type-II-Integral/","content":"第二型积分\n定义\n设 \\(\\Omega\\)\n为空间上一有向几何体，即在 \\(\\Omega\\)\n上每一点 \\(P\\) 处都确定了一方向 \\(\\overrightarrow{e_P}\\)，\\(P \\in \\Omega\\)，\\(\\overrightarrow{A}(P)\\) 为 \\(\\Omega\\) 上一向量值函数。首先，将 \\(\\Omega\\) 任意分成 \\(n\\) 个有向几何体 \\(\\Delta\\Omega_1, \\Delta\\Omega_2, \\cdots,\n\\Delta\\Omega_n\\)；然后在每一个有向几何体上做内积 \\(\\overrightarrow{A}(P) \\cdot\n\\Delta\\overrightarrow{\\Omega_i}(i = 1, 2, \\cdots, n), P_i \\in\n\\Delta\\Omega_i\\)，\\(\\Delta\\overrightarrow{\\Omega_i}\\) 是以\n\\(\\Delta\\Omega_i\\) 的几何量为模，以\n\\(P_i\\)\n点的方向为方向的向量，再将上述内积加起来得 \\(\\sum\\limits_{i=1}^n \\overrightarrow{A}(P_i) \\cdot\n\\Delta\\overrightarrow{\\Omega_i}\\)。若无论 \\(\\Omega\\) 如何分，\\(P_i \\in \\Delta \\Omega_i\\)如何取，极限 \\(\\lim\\limits_{\\lambda\\to 0}\\sum\\limits_{i=1}^n\n\\overrightarrow{A}(P_i) \\cdot \\Delta\n\\overrightarrow{\\Omega_i}\\)，\\(\\lambda\n= \\max\\{d_i \\vert i = 1,2,\\cdots, n\\}\\)，\\(d_i\\) 是 \\(\\Delta\n\\Omega_i\\) 的直径，都存在且相等，则称此极限值为 \\(\\overrightarrow{A}(P_i)\\) 在 \\(\\Omega\\) 上给定方向 \\(\\overrightarrow{e_P}\\)\n下的第二型积分，记为\n\\[\n\\lim\\limits_{\\lambda\\to 0} \\sum\\limits_{i=1}^n \\overrightarrow{A}(P_i)\n\\cdot \\Delta\\overrightarrow{\\Omega_i} \\triangleq \\int\\limits_\\Omega\n\\overrightarrow{A} (P) d \\overrightarrow{\\Omega}\n\\]\n性质\n第二型曲线积分\n定义\n设 \\(C\\)\n是空间一有向曲线，其方向为其切线给定方向，引入直角坐标，\\(\\overrightarrow{A}(P) =\n\\{P(x,y,z),Q(x,y,z),R(x,y,z)\\}\\) 是 \\(C\\) 上连续函数，则\n\\[\nd\\Omega \\cos\\alpha_P = dx,\\quad d\\Omega\\cos\\beta_P = dy,\\quad\nd\\Omega\\cos \\gamma_P = dz\n\\]\n称 \\(\\int\\limits_C \\overrightarrow{A}(P)\nd\\overrightarrow{\\Omega} = \\int\\limits_C Pdx + Qdy + Rdz\\) 为\n\\(\\overrightarrow{A}(x,y,z)\\) 在 \\(C\\)\n上给定方向的第二型曲线积分。\n计算方法\n参数法\n设曲线 \\(C\\) 为 \\(\\begin{cases}  x = x(t) \\\\  y = y(t) \\\\  z = z(t)\n\\end{cases}\\) 始点 \\(t=a\\)，终点\n\\(t=b\\)，\\(C\\) 为光滑曲线，则 \\[\n\\begin{split}\n    \\int\\limits_C Pdx + Qdy + Rdz &amp; = \\int_a^b Pdx(t) + Qdy(t) +\nRdz(t) \\\\\n    &amp; =\\int_a^b \\left[P x&#39;(t) + Qy&#39;(t) + Rz&#39;(t)\\right]dt\n\\end{split}\n\\]\n格林公式\n设 \\(D\\) 为单连通区域，\\(C\\) 为 \\(D\\)\n的边界闭曲线，其方向为正向。\\(P(x,y), Q(x,y)\\) 是 \\(C+D\\) 上具有连续一阶偏导的函数，则 \\[\n\\oint\\limits_C P(x,y)dx + Q(x,y)dy = \\oiint\\limits_D\n\\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial\ny}\\right) dxdy\n\\]\n推广\n设曲线 \\(C\\) 是由 \\(n+1\\) 条简单连续、逐段光滑闭曲线 \\(C_0, C_1, \\cdots, C_n\\) 组成，其中 \\(C_1, \\cdots, C_n\\) 互不相交，每条都在其余\n\\(n-1\\) 条外部区域内，而它们全体又在\n\\(C_0\\) 所围区域内部。\\(C_0\\) 与 \\(C_1,\n\\cdots, C_n\\) 所界定区域为 \\(D\\)，\\(C\\)\n的方向对 \\(D\\)\n而言为左手域方向，而 \\(P(x,y), Q(x,y)\\) 又是 \\(C+D\\) 上具有连续一阶偏导的函数，则 \\[\n\\oint\\limits_C P(x,y)dx + Q(x,y)dy = \\oiint\\limits_D\n\\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial\ny}\\right) dxdy\n\\]\n斯托克斯公式\n设 \\(C\\) 为分段光滑有向闭曲线，\\(S\\) 是以 \\(C\\) 为边界的任一分片光滑的有向曲面，\\(C\\) 与 \\(S\\)\n的方向满足右手螺旋方向，函数 \\(P(x,y,z), Q(x,y,z), R(x,y,z)\\) 是 \\(S+C\\) 上具有连续偏导的函数，则 \\[\n\\begin{split}\n    \\oint\\limits_C Pdx + Qdy + Rdz &amp; =\\iint\\limits_S\n\\left(\\frac{\\partial R}{\\partial y} - \\frac{\\partial Q}{\\partial\nz}\\right) dydz + \\left(\\frac{\\partial P}{\\partial z} - \\frac{\\partial\nR}{\\partial x}\\right) dzdx + \\left(\\frac{\\partial Q}{\\partial x} -\n\\frac{\\partial P}{\\partial y}\\right) dxdy \\\\\n    &amp; = \\iint\\limits_S \\begin{vmatrix}\n        dydz &amp; dzdx &amp; dxdy \\\\\n        \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y}\n&amp; \\frac{\\partial}{\\partial z} \\\\\n        P &amp; Q &amp; R\n    \\end{vmatrix} \\\\\n    &amp; = \\iint\\limits_S \\begin{vmatrix}\n        \\cos\\alpha &amp; \\cos\\beta &amp; \\cos\\gamma \\\\\n        \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y}\n&amp; \\frac{\\partial}{\\partial z} \\\\\n        P &amp; Q &amp; R\n    \\end{vmatrix} dS\n\\end{split}\n\\]\n平面曲线积分与路径无关\n设 \\(D\\) 为单连通区域，\\(P, Q\\) 为 \\(D\\) 上具有连续一阶偏导的函数，在 \\(D\\) 上下述四结论等价： 1. \\(D\\) 上任意闭曲线 \\(C\\)，有 \\(\\oint\\limits_C Pdx + Qdy = 0\\) 2. \\(D\\) 上第二型曲线积分 \\(\\int\\limits_{AB} Pdx + Qdy\\) 与路径无关 3.\n\\(Pdx + Qdy\\) 是全微分 4. \\(\\frac{\\partial P}{\\partial y} = \\frac{\\partial\nQ}{\\partial x}\\)\n全微分方程\n定义\n如果一阶微分方程 \\(Pdx + Qdy = 0\\)\n满足 \\(\\frac{\\partial P}{\\partial y} =\n\\frac{\\partial Q}{\\partial\nx}\\)，则称此方程为全微分方程（恰当方程）。\n解法\n\\[\n\\begin{split}\n    通解公式\\ u(x,y) = &amp; \\int_{(x_0, y_0)}^{(x,y)} Pdx + Qdy = C \\\\\n    &amp; \\int_{x_0}^x P(x,y_0)dx + \\int_{y_0}^y Q(x,y)dy = C\n\\end{split}\n\\]\n更一般地，方程两端乘以一个因子 \\(u(x,y)\\) 才可以变成全微分方程。\n空间曲线积分与路径无关\n设 \\(\\Omega\\)\n为空间二维单连通区域，\\(P, Q, R\\) 为\n\\(\\Omega\\) 上具有连续一阶偏导的函数，在\n\\(\\Omega\\) 上下述四结论等价： 1. \\(\\Omega\\) 上任意闭曲线 \\(C\\)，有 \\(\\oint\\limits_C Pdx + Qdy + Rdz = 0\\) 2.\n\\(\\Omega\\) 上第二型曲线积分 \\(\\int_{AB} Pdx + Qdy + Rdz\\) 与路径无关 3.\n\\(Pdx + Qdy + Rdz\\) 是全微分 4. \\(\\frac{\\partial R}{\\partial y} = \\frac{\\partial\nQ}{\\partial z}, \\frac{\\partial P}{\\partial z} = \\frac{\\partial\nR}{\\partial x}, \\frac{\\partial P}{\\partial y} = \\frac{\\partial\nQ}{\\partial x}\\)\n第二型曲面积分\n定义\n设 \\(S\\) 是空间一有向曲面，其方向\n\\(\\overrightarrow{n_P}, P \\in S\\)\n为给定 \\(S\\) 上一法向，\\(\\overrightarrow{A}(P) =\n\\{P(x,y,z),Q(x,y,z),R(x,y,z)\\}\\) 是 \\(S\\) 上连续函数，则 \\[\nd\\Omega \\cos\\alpha_P = dydz,\\quad d\\Omega\\cos\\beta_P = dzdx,\\quad\nd\\Omega\\cos \\gamma_P = dxdy\n\\] 称 \\(\\int\\limits_S\n\\overrightarrow{A}(P) d\\overrightarrow{\\Omega} = \\int\\limits_S Pdydz +\nQdzdx + Rdxdy\\) 为 \\(\\overrightarrow{A}(x,y,z)\\) 在 \\(S\\)\n上给定一侧的第二型曲面积分。\n计算方法\n分面计算法\n\\[\n\\iint\\limits_S Rdxdy = \\begin{cases}\n    \\iint\\limits_{D_{xy}} R(x, y, g(x,y)) dxdy &amp; S为上侧 \\\\\n    -\\iint\\limits_{D_{xy}} R(x,y, g(x,y)) dxdy &amp; S为下侧\n\\end{cases}\n\\]\n\\[\n\\iint\\limits_S Pdydz = \\begin{cases}\n    \\iint\\limits_{D_{yz}} P(g(y,z), y, z) dydz &amp; S为前侧 \\\\\n    -\\iint\\limits_{D_{yz}} R(g(y, z), y, z) dydz &amp; S为后侧\n\\end{cases}\n\\]\n\\[\n\\iint\\limits_S Qdzdx = \\begin{cases}\n    \\iint\\limits_{D_{xz}} Q(x, g(x, z), z) dxdy &amp; S为右侧 \\\\\n    -\\iint\\limits_{D_{xz}} Q(x, g(x, z), z) dxdy &amp; S为左侧\n\\end{cases}\n\\]\n投影法\n\\[\n\\begin{split}\n    \\iint\\limits_S Pdydz + Qdzdx + Rdxdy &amp; =\\iint\\limits_S\n\\left[P\\left(-\\frac{\\partial z}{\\partial x}\\right) +\nQ\\left(-\\frac{\\partial z}{\\partial y}\\right) + R\\right]dxdy \\\\\n    &amp; = \\pm \\iint\\limits_D \\left[P\\left(-\\frac{\\partial z}{\\partial\nx}\\right) + Q\\left(-\\frac{\\partial z}{\\partial y}\\right) + R\\right]dxdy\n\\end{split}\n\\]\n高斯公式\n设空间二维单连通区域 \\(\\Omega\\) 的边界 \\(S\\)\n是光滑的，其方向为外法方向，函数 \\(P(x,y,z)\\)，\\(Q(x,y,z)\\)，\\(R(x,y,z)\\) 在 \\(\\Omega\\) 上具有连续一阶偏导数，则有 \\[\n\\oiint\\limits_S Pdydz + Qdzdx + Rdxdy = \\iiint\\limits_\\Omega\n\\left(\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} +\n\\frac{\\partial R}{\\partial z}\\right) d\\Omega\n\\]\n推广\n设 \\(S\\) 是由两个闭曲面 \\(S_1, S_2\\) 组成，\\(S_1\\) 的方向为外法方向，\\(S_2\\) 的方向为内法方向，且 \\(S_2\\) 在 \\(S_1\\) 所围区域内部，介于 \\(S_1, S_2\\) 之间区域为 \\(\\Omega\\)，函数 \\(P(x,y,z), Q(x,y,z), R(x,y,z)\\) 在 \\(\\Omega\\) 与 \\(S\\) 上具有连续一阶偏导数，则有 \\[\n\\oiint\\limits_S Pdydz + Qdzdx + Rdxdy = \\iiint\\limits_\\Omega\n\\left(\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} +\n\\frac{\\partial R}{\\partial z}\\right) d\\Omega\n\\]\n向量场\n平均散发量\n散度\n定义\n\\(\\lim\\limits_{\\Delta\\Omega \\to M}\n\\frac{1}{\\Delta\\Omega} \\oiint\\limits_{\\Delta S} Pdydz + Qdzdx +\nRdxdy\\)（\\(\\Delta S\\)\n为外法方向），记为 \\(\\operatorname{div}\n\\overrightarrow{A}(M)\\)\n当 \\(\\operatorname{div}\\overrightarrow{A}(M) &gt;\n0\\) 时，\\(M\\) 点为 \\(\\overrightarrow{A}\\)\n的正源\n当 \\(\\operatorname{div}\\overrightarrow{A}(M) &lt;\n0\\) 时，\\(M\\) 点为 \\(\\overrightarrow{A}\\)\n的负源\n当 \\(\\operatorname{div}\\overrightarrow{A}(M) =\n0\\) 时，\\(M\\) 点非 \\(\\overrightarrow{A}\\) 的源\n计算\n\\[\n\\begin{split}\n    \\operatorname{div} \\overrightarrow{A}(M_0)&amp; =\n\\left(\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} +\n\\frac{\\partial R}{\\partial z}\\right)\\Bigg|_{M_0} \\\\\n    &amp; = \\nabla \\overrightarrow{A}(M_0)\n\\end{split}\n\\]\n环流面密度\n定义\n\\(\\lim\\limits_{\\Delta S \\to\nM}\\frac{1}{\\Delta S} \\oint\\limits_{\\Delta C} Pdx + Qdy +\nRdz\\)\n计算\n\\[\n\\lim\\limits_{\\Delta S \\to M}\\frac{1}{\\Delta S} \\oint\\limits_{\\Delta C}\nPdx + Qdy + Rdz = \\begin{vmatrix}\n        \\cos\\alpha &amp; \\cos\\beta &amp; \\cos\\gamma \\\\\n        \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y}\n&amp; \\frac{\\partial}{\\partial z} \\\\\n        P &amp; Q &amp; R\n    \\end{vmatrix}_M\n\\]\n旋度\n定义\n记为 \\(\\operatorname{rot}\\overrightarrow{A}(M) =\n\\overrightarrow{H}\\)\n","tags":["Math","Calculus"]},{"title":"服务器好玩的东西","url":"/2023/03/21/Ubuntu/","content":"前言\n由于软件安装教程具有时效性，故只放置官网链接。\n更新系统时间\ncp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n修改主机名\nvim /etc/hostnamevim /etc/hosts\n修改root密码\npasswd\n修改静态 IP\nnmtui #注意设置DNS\n挂载 NTFS 硬盘\nmount -t ntfs-3g /dev/sda3 /mnt/pssd\n开机自动挂载 NTFS 硬盘\nvim /etc/fstab/dev/sda3 /mnt ntfs-3g defaults 0 0\n系统监控软件\ns-tui\napt install python3-pip python3-dev -ypip3 install s-tui\nDDNS\nddns-go\n私有云\nNextcloud\nAList\n免费 SSL 证书\nacme.sh\nMC 服务器\n#先下载服务器版安装包 https://mcversions.net/apt install openjdk-17-jre -ymkdir /etc/minecraftcd /etc/minecraftjava -Xms2G -Xmx4G -jar server.jar noguivim eula.txteula=truevim /lib/systemd/system/minecraft.service[Unit]Description=Minecraft ServerWants=network.targetAfter=network.target[Service]Type=simpleWorkingDirectory=/etc/minecraft/ExecStart=/usr/bin/java -Xms2G -Xmx4G -jar /etc/minecraft/server.jar noguiRestartSec=30Restart=on-failureKillMode=processKillSignal=SIGINTSuccessExitStatus=130StandardInput=null[Install]WantedBy=default.targetsystemctl enable minecraftsystemctl start minecraft#记得在路由器上转发25565端口\n下载器\nAria2\nAriaNg\n媒体服务器\nPlex\nJellyfin\n网页版 SSH\nSshwifty\n博客\nHexo\nNexT\nButterfly\n科学上网\nv2rayA\n","tags":["Linux","Ubuntu","Sever"]},{"title":"Hello World","url":"/2024/04/02/hello-world/","content":"\n\n\n\n\n\n\n特征方程的根\n微分方程通解中的对应项\n\n\n\n\n\\(k\\) 重实根 \\(r\\)\n\\(e^{rx}(C_1 + C_2x + \\cdots + C_k\nx^{k-1})\\)\n\n\n一对 \\(k\\) 重复根 \\(r_{1,2} = \\alpha \\pm \\beta i\\)\n\\(e^{\\alpha x}[(C_1 + C_2x + \\cdots + C_k\nx^{k-1})\\cos \\beta x + (D_1 + D_2 x + \\cdots + D_k x^{k-1}) \\sin \\beta\nx]\\)\n\n\n\n"},{"title":"Ubuntu部署mqtt服务器","url":"/2024/04/02/mqtt/","content":"安装mosquitto\nsudo apt updatesudo apt install mosquitto mosquitto-clients\n启动服务\nsudo systemctl start mosquittosudo systemctl status mosquitto\n如果服务正常运行，应该看到类似这样的输出：\n● mosquitto.service - Mosquitto MQTT Broker   Loaded: loaded (/lib/systemd/system/mosquitto.service; enabled; vendor preset: enabled)   Active: active (running) since Mon 2023-03-13 10:05:25 UTC; 1min 30s ago     Docs: man:mosquitto.conf(5)           man:mosquitto(8) Main PID: 1234 (mosquitto)    Tasks: 1 (limit: 4915)   CGroup: /system.slice/mosquitto.service           └─1234 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.confMar 13 10:05:25 ubuntu systemd[1]: Starting Mosquitto MQTT Broker...Mar 13 10:05:25 ubuntu systemd[1]: Started Mosquitto MQTT Broker.\n创建用户和密码\nsudo mosquitto_passwd -c /etc/mosquitto/passwd &lt;username&gt;\n其中&lt;username&gt;是您想要创建的用户名。输入命令后会被要求输入和确认密码。这样会在/etc/mosquitto/passwd文件中创建一个新的用户和密码。\n启用密码验证\nsudo vim /etc/mosquitto/conf.d/default.conf\n添加以下内容：\nallow_anonymous falsepassword_file /etc/mosquitto/passwdlistener 8883\n重启服务并测试\nsudo systemctl restart mosquittomosquitto_sub -h localhost -t test -u &lt;username&gt; -P &lt;password&gt; -p 8883\n其中&lt;username&gt;和&lt;password&gt;是之前创建的用户和密码。这样就订阅了一个名为test的主题，并等待接收消息。\n在另一个终端中用以下命令来发布一条消息到test主题：\nmosquitto_pub -h localhost -t test -m &quot;hello world&quot; -u &lt;username&gt; -P &lt;password&gt; -p 8883\n然后可以在订阅端看到消息“hello world”\n"},{"title":"Windows VPN 连接报错：远程服务器未响应","url":"/2024/03/30/winVPN-ISSUE/","content":"\n省流: 修改注册表\n\n使用以下批处理代码，需要管理员权限，然后重启\n@echo off:: Set registry value for AssumeUDPEncapsulationContextOnSendRulereg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\PolicyAgent&quot; /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 2 /f:: Display success messageecho Registry value updated successfully.pause\n","categories":["Windows"],"tags":["VPN"]},{"title":"求解不定积分","url":"/2023/12/21/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","content":"概念\n不定积分是一种求原函数的方法，也就是求一个函数的反导数。不定积分的概念、性质和计算方法是高等数学的基础知识，对于理解定积分、微分方程、傅里叶级数等内容都有重要作用。\n求解方法\n不定积分的计算主要有以下几种方法\n基本积分公式\n如   \n利用不定积分的性质\n如   \n换元法\n即将一个复杂的积分转化为一个简单的积分，有两种类型：\n\n第一类换元法，也称为凑微分法，即将被积函数中的一部分替换为一个新的变量，使得剩下的部分正好是新变量的微分，如\n\n \n\n第二类换元法，也称为三角换元法，即将被积函数中的自变量替换为一个三角函数，使得积分的形式变得简单，如\n\n其中 其中\n分部积分法\n即将一个积分分解为两个函数的乘积，然后利用乘积的导数公式，如\n   从而得到 \n有理函数积分法\n即将一个分子和分母都是多项式的函数分解为若干个简单的分式的和，然后利用基本积分公式或换元法求解，如\n\n从而得到 \n","categories":["Calculus"],"tags":["Maths"]},{"title":"专业播放器挂载WebDav","url":"/2024/04/02/%E4%B8%93%E4%B8%9A%E6%92%AD%E6%94%BE%E5%99%A8%E6%8C%82%E8%BD%BDWebDav/","content":"还没动笔呢，别急\n"},{"title":"双指针算法","url":"/2023/11/23/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"双指针算法是一种常用的优化数组或链表操作的技巧，它可以避免使用暴力搜索或者多重循环，从而提高算法的效率。双指针算法的基本思想是使用两个指针（变量）来指向数组或链表中的元素，根据问题的要求，移动这两个指针来寻找目标值或者判断条件。在\nC++ 中，可以使用指针类型的变量或者迭代器来实现双指针算法。\n双指针算法有两种常见的形式：快慢指针和对撞指针。快慢指针是指两个指针以不同的速度或者步长在数组或链表中移动，常用于解决链表中的环问题、寻找中间节点等。对撞指针是指两个指针分别指向数组或链表的首尾，然后同时向中间移动，常用于解决两数之和、判断回文串等问题。\n举个例子\n下面是一个用 C++\n实现的双指针算法的例子，它的目的是在一个有序数组中找出两个数，使得它们的和等于给定的目标值。这个问题可以用对撞指针来解决，具体的思路是：\n\n定义两个指针 left 和\nright，分别指向数组的第一个元素和最后一个元素。\n计算 left 和 right 所指向的元素的和 sum，并与目标值 target\n比较。\n如果 sum 等于 target，说明找到了一对解，输出 left 和 right\n的下标，并结束循环。\n如果 sum 小于 target，说明和不够大，需要增大 sum，因此将 left\n向右移动一位，使得 left 所指向的元素变大。\n如果 sum 大于 target，说明和太大，需要减小 sum，因此将 right\n向左移动一位，使得 right 所指向的元素变小。\n重复上述步骤，直到 left 和 right 相遇或者找到解为止。\n\n代码如下：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 函数功能：在有序数组 nums 中找出两个数，使得它们的和等于 target// 参数：nums 是一个有序数组，target 是目标值// 返回值：一个包含两个下标的数组，如果没有找到解，返回空数组vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    // 定义两个指针，分别指向数组的首尾    int left = 0, right = nums.size() - 1;    // 定义一个存放结果的数组    vector&lt;int&gt; res;    // 循环条件是 left &lt; right    while (left &lt; right) &#123;        // 计算两个指针所指向的元素的和        int sum = nums[left] + nums[right];        // 如果和等于目标值，将两个下标放入结果数组，并结束循环        if (sum == target) &#123;            res.push_back(left);            res.push_back(right);            break;        &#125;        // 如果和小于目标值，将左指针向右移动一位        else if (sum &lt; target) &#123;            left++;        &#125;        // 如果和大于目标值，将右指针向左移动一位        else &#123;            right--;        &#125;    &#125;    // 返回结果数组    return res;&#125;int main() &#123;    // 定义一个有序数组    vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;    // 定义一个目标值    int target = 9;    // 调用函数，得到结果    vector&lt;int&gt; res = twoSum(nums, target);    // 如果结果不为空，输出结果    if (!res.empty()) &#123;        cout &lt;&lt; &quot;找到了一对解，下标分别是：&quot; &lt;&lt; res[0] &lt;&lt; &quot; 和 &quot; &lt;&lt; res[1] &lt;&lt; endl;    &#125;    // 如果结果为空，输出提示信息    else &#123;        cout &lt;&lt; &quot;没有找到解&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\nQ &amp; F\n\n这是否严谨？sum 小于 target，说明和不够大，可将 left\n向右移动一位，为什么不能将right右移一位？\n\n\n如果 right 右移一位，那么 sum 一定会变大，但是可能会超过\ntarget，导致结果不正确。所以，只有将 left 右移一位才能保证 sum 不会超过\ntarget，而且有可能等于 target。这是双指针算法的一个重要的原则。\n\n更多例子\n下面用C++代码给出一些双指针算法的例子：\n\n快慢指针判断链表是否有环：\n\n// 定义链表节点结构体struct ListNode &#123;    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;// 判断链表是否有环的函数bool hasCycle(ListNode *head) &#123;    // 如果链表为空或只有一个节点，返回false    if (head == NULL || head-&gt;next == NULL) return false;    // 定义快慢指针，初始都指向头节点    ListNode *slow = head, *fast = head;    // 循环条件是快指针不为空且快指针的下一个节点不为空    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;        // 快指针每次移动两个位置，慢指针每次移动一个位置        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        // 如果快慢指针相遇，说明有环，返回true        if (fast == slow) return true;    &#125;    // 如果循环结束，快慢指针没有相遇，说明没有环，返回false    return false;&#125;\n\n左右指针判断字符串是否回文：\n\n// 判断字符串是否回文的函数bool isPalindrome(string s) &#123;    // 如果字符串为空，返回true    if (s.empty()) return true;    // 定义左右指针，初始分别指向字符串的开头和末尾    int left = 0, right = s.size() - 1;    // 循环条件是左指针小于右指针    while (left &lt; right) &#123;        // 如果左指针指向的字符不是字母或数字，左指针右移        if (!isalnum(s[left])) left++;        // 如果右指针指向的字符不是字母或数字，右指针左移        else if (!isalnum(s[right])) right--;        // 否则，比较左右指针指向的字符是否相等，忽略大小写        else &#123;            // 如果不相等，返回false            if (tolower(s[left]) != tolower(s[right])) return false;            // 如果相等，左指针右移，右指针左移            else &#123;                left++;                right--;            &#125;        &#125;    &#125;    // 如果循环结束，左右指针没有发现不相等的字符，返回true    return true;&#125;\n\n对撞指针寻找三个数之和：\n\n// 寻找三个数之和的函数vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    // 定义结果数组    vector&lt;vector&lt;int&gt;&gt; res;    // 如果数组为空或长度小于3，返回空数组    if (nums.empty() || nums.size() &lt; 3) return res;    // 对数组进行升序排序    sort(nums.begin(), nums.end());    // 遍历数组，固定第一个数    for (int i = 0; i &lt; nums.size() - 2; i++) &#123;        // 如果第一个数大于0，后面的数都大于0，不可能和为0，直接返回结果        if (nums[i] &gt; 0) return res;        // 如果第一个数和前一个数相同，跳过重复的情况        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;        // 定义左右指针，初始分别指向第一个数的后一个数和数组的最后一个数        int left = i + 1, right = nums.size() - 1;        // 循环条件是左指针小于右指针        while (left &lt; right) &#123;            // 计算三个数之和            int sum = nums[i] + nums[left] + nums[right];            // 如果和为0，说明找到了一组解，将其加入结果数组            if (sum == 0) &#123;                res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);                // 左指针右移，跳过重复的数                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;                // 右指针左移，跳过重复的数                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;                // 左右指针同时向中间移动                left++;                right--;            &#125;            // 如果和小于0，说明需要增大和，左指针右移            else if (sum &lt; 0) left++;            // 如果和大于0，说明需要减小和，右指针左移            else right--;        &#125;    &#125;    // 返回结果数组    return res;&#125;\n","categories":["Algorithm"],"tags":["C++"]},{"title":"常用积分表","url":"/2024/04/02/%E7%A7%AF%E5%88%86%E8%A1%A8/","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Calculus"],"tags":["Maths"]}]